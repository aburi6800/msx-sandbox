; ====================================================================================================
; asm06.asm
; ====================================================================================================
SECTION code_user
PUBLIC _main

_main:
; ====================================================================================================
; 初期処理
; ====================================================================================================
    CALL INIT                   ; 初期設定

    ; テスト
    LD HL,STRING1
    CALL PRTSTR

    LD HL,STRING2
    CALL PRTSTR

    LD HL,STRING3
    CALL PRTSTR

    ; フィールド描画
    CALL GAME_INIT
    CALL ROUND_INIT

; ====================================================================================================
; メインループ
; ====================================================================================================
MAINLOOP:

    ; ■プレイヤー操作処理
    CALL PLAYER_UPDATE

    ; ■ボール処理
    CALL BALL_UPDATE

    ; ■画面更新
    CALL DRAW

VSYNC:
	; ■垂直帰線待ち
	HALT

	JR MAINLOOP


; ====================================================================================================
; プレイヤー操作処理
; ====================================================================================================
PLAYER_UPDATE:
    ; ■プレイヤーミスカウント判定
    ; - プレイヤーミスカウント<>0の場合は、操作を受け付けずにメッセージを表示して終了する
    LD A,(PLAYER_MISS_CNT)          ; A <- プレイヤーミスカウント
    OR A
    JR Z,PLAYER_UPDATE_L1           ; ゼロの時だけプレイヤー操作処理へ

    DEC A                           ; A=A-1
    LD (PLAYER_MISS_CNT),A          ; A -> プレイヤーミスカウント

    LD HL,STRING4                   ; 'MISS !!'表示
    CALL PRTSTR

    JR PLAYER_UPDATE_EXIT

PLAYER_UPDATE_L1:
    LD HL,STRING3
    CALL PRTSTR

    ; ■プレイヤー操作
    ; @ToDo:なぜか下方向だけ、一定量ごとに右に1ドット移動してしまう
    CALL PLAYER_CONTROL             ; プレイヤー操作処理
    CALL SPRITE_MOVE                ; スプライトキャラクター移動処理


PLAYER_UPDATE_EXIT:
    RET

; ----------------------------------------------------------------------------------------------------
; プレイヤー操作
; IN  : B = スプライトキャラクター番号
; ----------------------------------------------------------------------------------------------------
PLAYER_CONTROL:
    ; ■対象のスプライトキャラクターワークテーブルの先頭アドレスを取得
    LD B,0                          ; B <- ゼロ（プレイヤーのスプライトキャラクター番号）
    CALL GET_SPR_WK_ADDR            ; IX <- スプライトキャラクターワークテーブルのアドレス

    ; ■プレイヤー操作データ(STICK)を取得
    ;   本来はジョイスティックの入力も取得してOR演算する必要がある
    ;   その場合、キーボードとジョイスティックの両方を同時に入力した場合、
    ;   最大で16nになるため、ジャンプテーブルはそれを考慮したものとする
    CALL GET_STICK

    ; ■入力データをスプライトキャラクターワークテーブルに保存
    LD (IX+7),A
    OR A
    RET Z

    ; ■スプライトパターン番号更新
    CALL PLAYER_ANIM

    RET

; ----------------------------------------------------------------------------------------------------
; スプライトパターン番号更新
; IN  : B = スプライトキャラクター番号
; ----------------------------------------------------------------------------------------------------
PLAYER_ANIM:
    ; ここはキャラクターデータにパターンテーブルの番号を持たせて、
    ; パターンテーブルからアドレスを取得するようにしたい

    ; ■参照先のアニメーションパターンテーブルの次のアドレスを求める
    LD HL,(PTN_ADDR)			    ; HLレジスタにアニメーションパターンテーブルの参照アドレスの値をロード
                                    ; - 本来であれば、キャラクターごとにアニメーションパターンがちがうので、
                                    ;   スプライトキャラクターワークテーブルにこのアドレスを持っておきたい
    INC HL						    ; HL=HL+1(ひとつ次のデータのアドレスへ)

	; ■アニメーションパターンテーブルから値を取得する
	LD A,(HL)					    ; A <- (HL) (=アニメーションパターンテーブルの参照先アドレスの値)
    OR 0						    ; 0かどうか (0=アニメーションパターンテーブルの終端)
    JR NZ,PLAYER_ANIM_1             ; 0でなければPLAYER_ANIM_1にジャンプ

	; ■アニメーションパターンテーブルの参照先を先頭に戻す
    LD HL,PTN_TBL				    ; HLレジスタにアニメーションパターンテーブルの先頭アドレスを設定
	LD A,(HL)					    ; A <- (HL) (=アニメーションパターンテーブルの参照先アドレスの値)

PLAYER_ANIM_1:
	; ■アニメーションパターンテーブルからスプライトパターン番号を取得する
    LD (PTN_ADDR),HL			    ; アニメーションパターンテーブルの参照先アドレスを更新する

PLAYER_ANIM_2:
	SUB 1						    ; A=A-1（パターンテーブルの値はスプライトパターン番号+1が設定されているため）
	LD (IX+4),A		                ; Aレジスタの値をスプライトキャラクターワークテーブルのスプライトパターン番号に設定

PLAYER_ANIM_EXIT:
    RET


; ====================================================================================================
; ボール移動処理
; ====================================================================================================
BALL_UPDATE:
    LD B,MAX_BALL_CNT               ; B <- ボールの最大キャラクター数                                ; ここは面ごとの数を設定したい
 
BALL_UPDATE_L1:
    ; ■ボールのキャラクター番号算出    
    PUSH BC
    INC B

    ; ■ボール移動
    CALL SPRITE_MOVE                ; スプライトキャラクター移動処理
    CALL BALL_BOUND                 ; ボールバウンド処理

    ; ■ヒット判定
    LD A,(PLAYER_MISS_CNT)          ; プレイヤーミスカウント<>0なら衝突判定はしないで次のループ処理へ
    OR A
    JR NZ,BALL_UPDATE_L2

    LD C,0                          ; C <- 衝突判定用の相手キャラクター番号
    CALL HIT_CHECK                  ; 衝突判定
    JR NC,BALL_UPDATE_L2            ; ヒットしてなかったら次のループ処理へ
    LD A,20                         ; プレイヤーミスカウントを設定
    LD (PLAYER_MISS_CNT),A

BALL_UPDATE_L2:
    POP BC
    DJNZ BALL_UPDATE_L1

    RET 

; ----------------------------------------------------------------------------------------------------
; ボールバウンド処理
; 事前にIXにスプライトキャラクターワークテーブルの先頭アドレスを設定済であること
; ----------------------------------------------------------------------------------------------------
BALL_BOUND:
    ; ■移動方向のアドレスをHLレジスタに設定
    PUSH IX                         ; IX -> HL
    POP HL
    LD DE,7                         ; HL=HL+7
    ADD HL,DE

    ; ■Y座標をDレジスタに取得
    LD D,(IX+1)                     ; D <- スプライトキャラクターワークテーブル Y座標

BALL_BOUND_L1:
    ; ■Y座標が上端か調べる
    LD A,D
    CP 0
    JR NZ,BALL_BOUND_L2             ; 画面上端でなければ画面下端チェックへ

    ; ■Y座標が上端の場合の跳ね返りの方向決定
    ; - V=2の時：V=4
    ; - V=8の時：V=6
    LD A,(HL)                       ; A <- 今の移動方向
    LD (HL),4                       ; まずは次の移動方向を4とする
    CP 2
    JR Z,BALL_BOUND_L3              ; 移動方向=2の場合はこのままでいいので、画面左端チェックへ

    LD (HL),6                       ; V=8の時はここに来る、次の移動方向を6にする
    JR BALL_BOUND_L3                ; 画面上端の場合が画面下端チェックは不要、画面左端チェックへ

BALL_BOUND_L2:
    ; ■Y座標が画面下端か調べる
    LD A,D
    CP 191-16
    JR NZ,BALL_BOUND_L3             ; 画面下端でなければ画面左端チェックへ

    ; ■Y座標が下端の場合の跳ね返りの方向決定
    ; - V=4の時：V=2
    ; - V=6の時：V=8
    LD A,(HL)                       ; A <- 移動方向
    LD (HL),2                       ; まずは2とする
    CP 4

    JR Z,BALL_BOUND_L3
    LD (HL),8                       ; V=6の時はここに来る

BALL_BOUND_L3:
    ; ■X座標をDEレジスタに取得
    LD D,(IX+3)                     ; D <- スプライトキャラクターワークテーブル(X座標)

    ; ■X座標が画面左端か調べる
    LD A,D
    CP 0
    JR NZ,BALL_BOUND_L4             ; 画面左端でなければ画面右端チェックへ

    ; ■跳ね返りの方向決定(X<0の時)
    ; - V=8の時：V=2
    ; - V=6の時：V=4
    LD A,(HL)                       ; A <- 移動方向
    LD (HL),2                       ; まずは2とする
    CP 8
    JR Z,BALL_BOUND_EXIT

    LD (HL),4                       ; V=6の時はここに来る
    JR BALL_BOUND_EXIT

BALL_BOUND_L4:
    ; ■X座標が右端か調べる
    LD A,D
    CP 255-16
    JR NZ,BALL_BOUND_EXIT           ; 画面右端でなければ終了

    ; ■跳ね返りの方向決定(X>239の時)
    ; - V=2の時：V=8
    ; - V=4の時：V=6
    LD A,(HL)                       ; A <- 移動方向
    LD (HL),8                       ; まずは2とする
    CP 2
    JR Z,BALL_BOUND_EXIT

    LD (HL),6                       ; V=6の時はここに来る

BALL_BOUND_EXIT:
    RET


; ====================================================================================================
; スプライトキャラクター移動処理
; IN  : B = スプライトキャラクター番号
; ====================================================================================================
SPRITE_MOVE:
    PUSH BC
    
    ; ■対象のスプライトキャラクターワークテーブルの先頭アドレスを取得
    CALL GET_SPR_WK_ADDR            ; IX <- スプライトキャラクターワークテーブルのアドレス

    ; ■対象スプライトキャラクターの移動方向から移動量データのアドレス算出
    LD A,(IX+7)                     ; A=移動方向
    OR A                            ; 移動方向が0(=移動しない)場合は終了
    JR Z,SPRITE_MOVE_EXIT

    RLCA                            ; A=A*2
    RLCA                            ; A=A*2、ここで移動量データのオフセットがAに設定される

    LD HL,MOVE_DATA                 ; HLレジスタに移動量データのアドレスを設定
    ADD HL,A

    PUSH HL                         ; HL -> IY
    POP IY

    ; ■Y座標計算
    LD B,(IY+1)                     ; BC <- 移動量データ(Y方向)
    LD C,(IY)
    LD H,(IX+1)                     ; HL <- スプライトキャラクターワークテーブル Y座標
    LD L,(IX)
    ADC HL,BC                       ; HL=HL+BC

    ; ■Y座標チェック
    LD A,H                          ; 座標値チェック
    CP 191-16                       ; A=A-(191-16)
    JR C,SPRITE_MOVE_L1             ; キャリーフラグがONの場合は画面内なのでSPRITE_MOVE_L1へ

    LD H,0                          ; H=0
    CP 255-8                        ; 最大移動量を8と仮定した比較
    JR NC,SPRITE_MOVE_L1            ; キャリーフラグがOFF(=画面上部にはみ出てた場合)はHはそのままで良いのでSPRITE_MOVE_L1へ

    LD H,191-16                     ; H=(191-16)

SPRITE_MOVE_L1:
    ; ■Y座標を保存
    LD (IX+1),H
    LD (IX),L

    ; ■X座標計算
    LD B,(IY+3)                     ; BC <- 移動量データ(X方向)
    LD C,(IY+2)
    LD H,(IX+3)                     ; HL <- スプライトキャラクターワークテーブル(X座標)
    LD L,(IX+2)
    ADC HL,BC                       ; HL=HL+BC

    ; ■X座標チェック
    LD A,H                          ; 座標値チェック
    CP 255-16                       ; A=A-(255-16)
    JR C,SPRITE_MOVE_L2             ; キャリーフラグがONの場合は画面内なのでSPRITE_MOVE_L2へ

    LD H,0                          ; H=0
    CP 255-8                        ; 最大移動量を8と仮定した比較
    JR NC,SPRITE_MOVE_L2            ; キャリーフラグがOFF(=画面左部にはみ出てた場合)はHはそのままで良いのでSPRITE_MOVE_L2へ

    LD H,255-16                     ; H=255-16

SPRITE_MOVE_L2:
    ; ■X座標を保存
    LD (IX+3),H
    LD (IX+2),L

SPRITE_MOVE_EXIT:
    POP BC
    RET


; ====================================================================================================
; キャラクター衝突判定処理
; 2つのキャラクターの座標を比較して、衝突していた場合はキャリーフラグを立てて戻る
; DE,HLレジスタの値を破壊します
; IN  : C = 比較先のキャラクター番号
; OUT : キャリーフラグ(ON=衝突している、OFF=衝突していない)
; ====================================================================================================
HIT_CHECK:
    PUSH BC

    ; ■比較先のキャラクター番号からスプライトキャラクターワークテーブルのアドレスを求める
    ; - IXレジスタは比較元の情報として残しておきたいので、一度スタックに退避し、
    ;   ここで取得したアドレスはHLレジスタに入れておく
    PUSH IX
    LD B,C
    CALL GET_SPR_WK_ADDR
    PUSH IX
    POP HL
    POP IX

    ; ■キャリーフラグリセット
    OR A

    ; ■Y座標の比較
    LD A,(IX+1)                 ; 比較元のY座標
    INC HL                      ; 比較先のY座標
    LD B,(HL)                   
    CALL ABS_SUB                ; 差分を絶対値で取得
    CP 10                       ; A < 10 の場合はキャリーフラグが立つ
    JR NC,HIT_CHECK_EXIT        ; キャリーフラグが立っていない場合は終了

    ; ■X座標の比較
    LD A,(IX+3)                 ; 比較元のX座標
    INC HL                      ; 比較先のX座標
    INC HL
    LD B,(HL)
    CALL ABS_SUB                ; 差分を絶対値で取得
    CP 10                       ; A < 10 の場合はキャリーフラグが立つ

HIT_CHECK_EXIT:
    POP BC
    RET


; ====================================================================================================
; 画面更新
; ====================================================================================================
DRAW:
    DI

    ; ■スプライトキャラクターワークテーブルからスプライトアトリビュートワークテーブルを設定
    CALL SET_SPR_ATR_WK

    ; ■スプライトアトリビュートエリア設定
    CALL SET_SPR_ATTR_AREA

DRAW_EXIT:
    EI
    RET


; ====================================================================================================
; ゲーム初期化処理
; ====================================================================================================
GAME_INIT:
    LD A,1
    LD (ROUND),A                ; ラウンド数 <- 1
    LD A,0
    LD (SCORE),A                ; スコア <- 0
    LD A,3
    LD (LEFT),A                 ; 残機 <- 3

    RET


; ====================================================================================================
; ラウンド初期処理
; ====================================================================================================
ROUND_INIT:
    ; ■VRAMアドレスワーク設定
    LD H,$1A                    ; 書き込み開始VRAMアドレス = $1ADE
    LD L,$DE
    LD (VRAM_ADDR_WK),HL

    ; ■ラウンドテーブルのオフセット値算出
    LD A,(ROUND)                ; A <- ラウンド数
    SUB 1                       ; A=A-1
    RLCA                        ; A=A*2
    LD B,A                      ; BC <- A
    LD C,0

    ; ■ラウンドデータの取得先アドレス算出
    ; - 遡って取得するので、末端のアドレスを算出する
    LD HL,ROUND_TBL             ; HL <- ラウンドテーブルの取得先アドレス
    ADD HL,BC                   ; HL=HL+BC

    LD E,(HL)                   ; DE <- (HL) ラウンドデータの先頭アドレス
    INC HL
    LD D,(HL)
    LD BC,175                   ; BC <- ラウンドデータのbyte数
    PUSH DE
    POP HL
    ADD HL,BC                   ; HL=HL+BC

    ; ■フィールド描画ループ回数設定
    LD B,176                    ; フィールドデータカウント (176byte)
    
ROUND_INIT_L1:
    PUSH HL                     ; ラウンドデータの取得先アドレスをスタックに退避
    PUSH BC                     ; フィールドデータカウントをスタックに退避

    ; ■ラウンドデータからマップチップデータを取得
    LD A,(HL)                   ; A <- (HL)   

    ; ■取得した値からジャンプテーブルアドレスのオフセット値を求める
    LD C,A                      ; A=A*3
    ADD A,A
    ADD A,C

    LD B,0                      ; ジャンプテーブルのオフセット値
    LD C,A

    ; ■ジャンプテーブルの該当ステップにジャンプ
    LD HL,ROUND_INIT_L2         ; HL <- ジャンプテーブルのアドレス
    ADD HL,BC                   ; HL=HL+BC
    JP (HL)

ROUND_INIT_L2:    
    JP ROUND_INIT_L31           ; データ=0の描画
    JP ROUND_INIT_L32           ; データ=1の描画

ROUND_INIT_L31:    
    ; 空白を描画(左上)
    LD HL,(VRAM_ADDR_WK)        ; HL <- VRAMアドレスワーク
    LD A,' '
    CALL WRTVRM

    ; 空白を描画(右上)
    INC HL                      ; HL=HL+1
    LD A,' '
    CALL WRTVRM

    ; 空白を描画(左下)
    LD DE,31                    ; HL=HL+31
    ADD HL,DE                   
    LD A,' '
    CALL WRTVRM

    ; 空白を描画(右下)
    INC HL                      ; HL=HL+1
    LD A,' '
    CALL WRTVRM

    JR ROUND_INIT_L4

ROUND_INIT_L32:    
    ; 床を描画(左上)
    LD HL,(VRAM_ADDR_WK)        ; HL <- VRAMアドレスワーク
    LD A,'a'
    CALL WRTVRM

    ; 床を描画(右上)
    INC HL                      ; HL=HL+1
    LD A,'a'
    CALL WRTVRM

    ; 床を描画(左下)
    LD DE,31                    ; HL=HL+31
    ADD HL,DE                   
    LD A,'a'
    CALL WRTVRM

    ; 床を描画(右下)
    INC HL                      ; HL=HL+1
    LD A,'a'
    CALL WRTVRM

    JR ROUND_INIT_L4

ROUND_INIT_L4:    
    LD HL,(VRAM_ADDR_WK)        ; HL <- VRAMアドレスワーク
    DEC HL                      ; HL=HL-2
    DEC HL

    POP BC                      ; BC <- スタック(フィールドデータカウント)
    LD A,B                      ; Bレジスタを左に4ビットシフト
    DEC A
    SLA A
    SLA A
    SLA A
    SLA A
    JR NZ,ROUND_INIT_L5         ; ゼロではない(=16の倍数でない)場合はROUND_INIT_L5へ

    OR A                        ; キャリーフラグをOFF
    LD DE,32                    ; HL=HL-32
    SBC HL,DE

ROUND_INIT_L5:    
    LD (VRAM_ADDR_WK),HL        ; HL -> VRAMアドレスワーク

    POP HL                      ; HL <- スタック(ラウンドデータの取得先アドレス)
    DEC HL
    DJNZ ROUND_INIT_L1

ROUND_INIT_EXIT:
    RET


; ====================================================================================================
; 初期設定
; ====================================================================================================
INIT:
    ; ■画面初期化
    CALL SCREEN_INIT

    ; ■フォントパターン定義
    CALL SET_FONT_PATTERN

    ; ■PCGパターン定義
    CALL SET_PCG_PATTERN

    ; ■カラーテーブル定義
    CALL SET_COLOR_TABLE

    ; ■スプライトパターン定義
    CALL SET_SPRITE_PATTERN

    ; ■スプライトキャラクターワークテーブル初期化
    CALL INIT_SPRITE_CHARACTER_WK

    RET


; ====================================================================================================
; 画面初期化
; ====================================================================================================
SCREEN_INIT:
    ; ■COLOR 15,1,1
    LD A,15                         ; Aレジスタに文字色をロード 
    LD (FORCLR),A                   ; Aレジスタの値をワークエリアに格納
    LD A,1                          ; Aレジスタに全景色をロード
    LD (BAKCLR),A                   ; Aレジスタの値をワークエリアに格納
;    LD A,1                         ; Aレジスタに背景色をロード
    LD (BDRCLR),A                   ; Aレジスタの値をワークエリアに格納

    ; ■SCREEN 1,2,0
    LD A,(REG1SAV)                  ; AレジスタにVDPコントロールレジスタ1の値をロード
    OR 2                            ; ビット2を立てる(=スプライトモードを16x16に設定)
    LD (REG1SAV),A                  ; Aレジスタの値をVDPコントロールレジスタ1のワークエリアに格納
    LD A,1                          ; Aレジスタにスクリーンモードの値を設定
    CALL CHGMOD                     ; BIOS スクリーンモード変更
    LD A,0                          ; Aレジスタにキークリックスイッチの値(0=OFF)をロード
    LD (CLIKSW),A                   ; Aレジスタの値をワークエリアに格納

    ; ■WIDTH 32
    LD A,32                         ; AレジスタにWIDTHの値を設定
    LD (LINL32),A                   ; Aレジスタの値をワークエリアに格納

    ; ■KEY OFF
    CALL ERAFNC                     ; BIOS ファンクションキー非表示

    RET


; ====================================================================================================
; フォントパターン定義
; ====================================================================================================
SET_FONT_PATTERN:
	LD HL,FONT_PTN_DATA			    ; HLレジスタに転送元データの先頭アドレスを設定
    LD DE,PTN_GEN_ADDR+32*8         ; DEレジスタに転送先アドレスを設定
	LD BC,8*64					    ; BCレジスタにデータサイズを指定
    CALL LDIRVM					    ; BIOS VRAMブロック転送

    RET


; ====================================================================================================
; PCGパターン定義
; ====================================================================================================
SET_PCG_PATTERN:
    LD HL,PCG_PTN_DATA          ; HL <- PCGデータの先頭アドレス

SET_PCG_PATTERN_L1:
    LD A,(HL)                   ; A <- PCGデータのキャラクターコード
    OR A                        ; A=ゼロなら抜ける
    JR Z,SET_PCG_PATTERN_EXIT

    ; DEレジスタにコピー先のアドレスを設定
    ; $0000+キャラクターコード*8
    PUSH HL                     ; HLを退避
    LD H,0                      ; HL <- A
    LD L,A
    ADD HL,HL                   ; HL=HL*8
    ADD HL,HL
    ADD HL,HL
    LD D,H                      ; DE <- HL
    LD E,L    
    POP HL

    ; HLレジスタにコピー元のアドレスを設定
    INC HL                      ; HL=HL+1
    
    ; BCレジスタに転送バイト数を設定
    LD BC,8                     ; 8バイトを転送
    PUSH BC
    PUSH HL
    CALL LDIRVM                 ; BIOS VRAMブロック転送
    POP HL
    POP BC
    
    ADD HL,BC                   ; HL <- 次のPCGデータのアドレス(+8)
    JR SET_PCG_PATTERN_L1

SET_PCG_PATTERN_EXIT:
    RET


; ====================================================================================================
; カラーテーブル定義
; ====================================================================================================
SET_COLOR_TABLE:
    ; HLレジスタにコピー元のアドレスを設定
    LD HL,PCG_COLOR_DATA        ; HL <- PCGカラーデータの先頭アドレス

    ; DEレジスタにコピー先のアドレスを設定
    LD DE,COLOR_TABLE_ADDR      ; DE <- カラーテーブルの先頭アドレス

    ; BCレジスタに転送バイト数を設定
    LD BC,32                    ; B <- カラーテーブルの設定先アドレス加算値

    CALL LDIRVM                 ; BIOS VRAMブロック転送

SET_COLOR_TABLE_EXIT:
    RET


; ====================================================================================================
; スプライトパターン定義
; ====================================================================================================
SET_SPRITE_PATTERN:
	LD HL,SPR_PTN_DATA			    ; HLレジスタにスプライトデータの先頭アドレスを設定
    LD DE,SPR_PTN_ADDR			    ; DEレジスタにスプライトパターンジェネレータの先頭アドレスを設定
	LD BC,8*4*4					    ; BCレジスタにスプライトデータのサイズを指定
    CALL LDIRVM					    ; BIOS VRAMブロック転送

    RET


; ====================================================================================================
; スプライトキャラクターワークエリア初期化
; ====================================================================================================
INIT_SPRITE_CHARACTER_WK:
    CALL INIT_SPR_CHR_WK_TBL
    CALL INIT_PLAYER
    CALL INIT_BALL

INIT_SPRITE_CHARACTER_WK_EXIT:
    RET


; ====================================================================================================
; スプライトキャラクターワークテーブル初期化
; ====================================================================================================
INIT_SPR_CHR_WK_TBL:
    LD B,MAX_CHR_CNT                ; 最大キャラクター数

INIT_SPR_CHR_WK_TBL_L1:
    CALL GET_SPR_WK_ADDR            ; スプライトキャラクターワークテーブルのアドレスを取得

    LD (IX),0                       ; Y座標
    LD (IX+1),-16
    LD (IX+2),0                     ; X座標
    LD (IX+3),-16
    LD (IX+4),0                     ; スプライトパターンNo
    LD (IX+5),0                     ; カラーコード
    LD (IX+6),0                     ; 属性テーブルNo(0=なし)
    LD (IX+7),0                     ; 移動方向

    DJNZ INIT_SPR_CHR_WK_TBL_L1

INIT_SPR_CHR_WK_TBL_EXIT:
    RET 


; ====================================================================================================
; プレイヤー初期化
; ====================================================================================================
INIT_PLAYER:
    LD B,0                          ; B=ゼロ(プレイヤーのキャラクター番号)
    CALL GET_SPR_WK_ADDR            ; スプライトキャラクターワークテーブルのアドレスを取得

    LD (IX),0                       ; Y座標
    LD (IX+1),88

    LD (IX+2),0                     ; X座標
    LD (IX+3),120

    LD (IX+4),0                     ; スプライトパターンNo
    LD (IX+5),15                    ; カラーコード
    LD (IX+6),1                     ; 属性テーブルNo(1=プレイヤー)
    LD (IX+7),0                     ; 移動方向

	LD HL,PTN_TBL				    ; アニメーションパターンテーブル参照先アドレス初期化
    LD (PTN_ADDR),HL

INIT_PLAYER_EXIT:
    RET


; ====================================================================================================
; ボール初期化
; ====================================================================================================
INIT_BALL:
    CALL INIT_RND                   ; 乱数シード初期化
    LD B,MAX_BALL_CNT               ; B=最大ボール数

INIT_BALL_L1:
    PUSH BC
    INC B                           ; ボールのキャラクター番号は1からなので、B=B+1する
    CALL GET_SPR_WK_ADDR            ; スプライトキャラクターワークテーブルのアドレスを取得

INIT_BALL_L2:
    ; ■Y座標設定
    CALL GET_RND                    ; 乱数取得(0〜255)
    CP 176                          ; A=A-176
    JR NC,INIT_BALL_L2              ; Aが176を超えていたら再度乱数取得
    LD H,A
    LD L,0
    LD (IX+0),L                     ; Y座標(下位)
    LD (IX+1),H                     ; Y座標(上位)

INIT_BALL_L3:
    ; ■X座標設定
    CALL GET_RND                    ; 乱数取得(0〜255)
    CP 248                          ; A=A-248
    JR NC,INIT_BALL_L3              ; Aが248を超えていたら再度乱数取得
    LD H,A
    LD L,0
    LD (IX+2),L                     ; X座標(下位)
    LD (IX+3),H                     ; X座標(上位)

    ; ■パターンNo設定
    LD (IX+4),3                     ; パターンNo=3(ボール)
    
INIT_BALL_L4:
    ; ■カラーコード設定
    CALL GET_RND                    ; 乱数取得(0〜255)
    AND 15                          ; 取得した乱数から0〜15の値を取得する
    ADD A,1                         ; A=A+1
    ADD A,1                         ; A=A+1
    CP 15                           ; Aが15を超えていたら再度乱数取得
    JR NC,INIT_BALL_L4 
    LD (IX+5),A                     ; カラーコード

    ; ■属性テーブルNo設定
    LD (IX+6),2                     ; 2(=ボール)固定

    ; ■方向設定
    CALL GET_RND                    ; 乱数取得(0〜255)
    AND @00000111                   ; 取得した乱数から0〜7の値を取得する
    ADD A,2                         ; A=A+2(カラーコード=1は除外するため)
    AND @00001110                   ; 下位1ビットを0にする()=2,4,6,8の値にする)
    LD (IX+7),A                     ; 方向

    PUSH IX
    POP HL
    LD DE,10
    ADD HL,DE                       ; テーブルの次の先頭アドレスへ

    POP BC
    DJNZ INIT_BALL_L1

INIT_BALL_EXIT:
	RET


; ====================================================================================================
; スプライトキャラクターワークテーブルからスプライトアトリビュートワークテーブルを設定する
; ====================================================================================================
SET_SPR_ATR_WK:
    LD B,MAX_CHR_CNT                ; スプライトキャラクター分繰り返し
    LD HL,SPR_CHR_WK_TBL            ; スプライトキャラクターワークテーブルの先頭アドレス
    LD DE,SPR_ATR_WK_TBL            ; スプライトアトリビュートワークテーブルの先頭アドレス

SET_SPR_ATR_WK_L1:
    ; ■Y座標
    INC HL                          ; HL=HL+1 (Y座標の上位1バイトのアドレス)
    LD A,(HL)                       ; (HL)→A
    LD (DE),A                       ; A→(DE)

    ; ■X座標
    INC HL                          ; HL=HL+2 (X座標の上位1バイトのアドレス)
    INC HL
    LD A,(HL)                       ; (HL)→A
    INC DE                          ; DE=DE+1
    LD (DE),A                       ; A→(DE)

    ; ■スプライトパターンNo
    INC HL                          ; HL=HL+1
    LD A,(HL)                       ; (HL)→A
    ADD A,A                         ; A=A*4 (スプライトが16x16なので、パターンNoを4倍する)
    ADD A,A
    INC DE                          ; DE=DE+1
    LD (DE),A                       ; A→(DE)

    ; ■カラーコード
    INC HL                          ; HL=HL+1
    LD A,(HL)                       ; (HL)→A
    INC DE                          ; DE=DE+1
    LD (DE),A                       ; A→(DE)

    ; ■設定元のスプライトキャラクターワークテーブルのアドレスを次の先頭アドレスへ
    INC HL                          ; HL=HL+5
    INC HL
    INC HL
    INC HL
    INC HL

    ; ■設定先のスプライトアトリビュートワークテーブルのアドレスを次の先頭アドレスへ
    INC DE                          ; DE=DE+1

    DJNZ SET_SPR_ATR_WK_L1

SET_SPR_ATR_WK_EXIT:
    RET


; ====================================================================================================
; スプライトアトリビュートエリア設定
; ====================================================================================================
SET_SPR_ATTR_AREA:
    LD HL,SPR_ATR_WK_TBL            ; スプライトアトリビュートワークテーブル
    LD DE,SPR_ATR_ADDR              ; スプライトアトリビュートエリア
    LD BC,4*MAX_CHR_CNT             ; 転送バイト数(4byte*キャラクター数)
    CALL LDIRVM                     ; BIOS VRAMブロック転送

    RET 


; ====================================================================================================
; 文字列表示サブルーチン
; IN  : HL = 表示文字データの開始アドレス
; ====================================================================================================
PRTSTR:
    LD B,(HL)                       ; BC <- HLアドレスの示すオフセット値データ
    INC HL
    LD C,(HL)

    INC HL                          ; HL <- 文字列データの先頭アドレス
    PUSH HL                         ; HL -> DE
    POP DE

    LD HL,PTN_NAME_ADDR             ; HL <- パターンネームテーブルの先頭アドレス
    ADD HL,BC                       ; HL=HL+BC

PRTSTR_L1:
	LD A,(DE)				        ; AレジスタにDEレジスタの示すアドレスのデータを取得

	OR 0					        ; 0かどうか
    JR Z,PRTSTR_END			        ; 0の場合はPRTENDへ

	CALL WRTVRM				        ; BIOS WRTVRM呼び出し
	    					        ; - HL : 書き込み先のVRAMアドレス
    	                            ; - A  : 書き込むデータ

	INC HL					        ; HL=HL+1
    INC DE					        ; DE=DE+1
    JR PRTSTR_L1

PRTSTR_END:
	RET


; ====================================================================================================
; プレイヤー操作情報取得サブルーチン
; ====================================================================================================
GET_STICK:
    CALL KILBUF                     ; BIOS キーバッファクリア

    ; ■カーソルキー／ジョイスティックの入力をワークエリアに設定
    ;   前回までの入力値との比較をできるようにワークエリアは2byte取ってあるが
    ;   今は使っていない
    XOR A
    CALL GTSTCK                     ; BIOS スティック値取得
;    OR A
;    JR Z,GET_STICK_END              ; ゼロだったら終了
    
    LD (INPUT_BUFF_STICK),A         ; 入力バッファ(STICK)に入力値を設定    

GET_STICK_END:
    RET


; ====================================================================================================
; 絶対値減算サブルーチン
; IN  : A = 値１
;       B = 値２
; OUT : A = A-Bの絶対値
; ====================================================================================================
ABS_SUB:
    OR A
    SUB B                           ; A=A-B
    JP M,ABS_SUB_L1                 ; マイナスだったらABS_SUB_L1へ
    RET

ABS_SUB_L1:
    NEG                             ; 上記の結果を正負反転
	ADD A,$FF                       ; A=A+$FF
    ADD A,1                         ; さらに1加算して一巡させる
    RET


; ====================================================================================================
; 乱数初期化サブルーチン
; ====================================================================================================
INIT_RND:
    LD A,(INTCNT)
    LD (RND_WK),A                   ; 乱数のシード値を設定

    RET


; ====================================================================================================
; 乱数取得サブルーチン
; 事前にINIT_RNDを実行しておくこと
; OUT : A = 0〜255の範囲の乱数
; ====================================================================================================
GET_RND:
    PUSH BC
    
    LD A,(RND_WK)                   ; 乱数のシード値を乱数ワークエリアから取得
    LD B,A
    LD A,B

    ADD A,A                         ; A=A*5
    ADD A,A                         ;
    ADD A,B                         ;

    ADD A,123                       ; 123を加える
    LD (RND_WK),A                   ; 乱数ワークエリアに保存

GET_RND_EXIT:
    POP BC
    RET


; ====================================================================================================
; スプライトキャラクターワークテーブルのアドレス値を求める
; DE,HLレジスタの値を破壊します。
; IN  : B = キャラクターNo
; OUT : IX = アドレス
; ====================================================================================================
GET_SPR_WK_ADDR:
    ; ■スプライトキャラクターワークテーブルの先頭アドレス
    LD IX,SPR_CHR_WK_TBL            ; IXに設定

    ; ■算出対象かチェック
    DEC B
    INC B
    JR Z,GET_SPR_WK_ADDR_EXIT       ; B=0ならそのまま終了する

    ; ■オフセット値算出
    LD D,0                          ; DE=B
    LD E,B

    LD H,0                          ; HL=B
    LD L,B
    
    ADD HL,HL                       ; HL=HL*8
    ADD HL,HL
    ADD HL,HL
    ADD HL,DE                       ; HL=HL+(DE*2)
    ADD HL,DE

    ; ■スプライトキャラクターワークテーブルのアドレス算出
    LD D,H                          ; HL -> DE
    LD E,L
    LD HL,SPR_CHR_WK_TBL            ; HL=スプライトキャラクターワークテーブルの先頭アドレス
    ADD HL,DE                       ; HL=HL+DE

    PUSH HL                         ; HL -> IX
    POP IX

GET_SPR_WK_ADDR_EXIT:
    RET 


; ====================================================================================================
; 定数エリア
; romに格納される
; ====================================================================================================
SECTION rodata_user

; ■BIOSアドレス定義
RDVRM:		        EQU $004A	    ; BIOS RDVRM
WRTVRM:		        EQU $004D	    ; BIOS WRTVRM
LDIRVM:			    EQU	$005C	    ; BIOS:VRAMブロック転送
CHGMOD:             EQU $005F       ; BIOS:スクリーンモード変更
ERAFNC:             EQU $00CC       ; BIOS:ファンクションキー非表示
KILBUF:             EQU $0156       ; BIOS:キーバッファクリア
GTSTCK:             EQU $00D5       ; BIOS:カーソルキー・ジョイスティックのの状態取得

; ■システムワークエリアアドレス定義
REG0SAV:            EQU $F3DF       ; VDPコントロールレジスタ0
REG1SAV:            EQU $F3E0       ; VDPコントロールレジスタ1
FORCLR:             EQU $F3E9       ; 前景色
BAKCLR:             EQU $F3EA       ; 背景色
BDRCLR:             EQU $F3EB       ; 周辺色
LINL32:             EQU $F3AF       ; WIDTH値
CLIKSW:             EQU $F3DB       ; キークリックスイッチ(0:OFF,0以外:ON)
INTCNT:             EQU $FCA2       ; システムで1/60秒でインクリメントするワークエリア

; ■VRAMワークエリアアドレス定義
PTN_GEN_ADDR:       EQU $0000       ; VRAM:パターンジェネレータテーブルの先頭アドレス
PTN_NAME_ADDR:      EQU $1800       ; VRAM:パターンネームテーブルの先頭アドレス
COLOR_TABLE_ADDR:   EQU $2000       ; VRAM:カラーテーブルの先頭アドレス
SPR_PTN_ADDR:	    EQU $3800	    ; VRAM:スプライトパターンジェネレータの先頭アドレス
SPR_ATR_ADDR:	    EQU	$1B00	    ; VRAM:スプライトアトリビュートエリアの先頭アドレス

; ■定数定義
MAX_CHR_CNT:        EQU 32          ; 最大キャラクター数
MAX_BALL_CNT:       EQU 5           ; 最大ボール数

STATE_TITLE:        EQU 1           ; ゲーム状態：タイトル
STATE_GAME:         EQU 2           ; ゲーム状態：ゲーム
STATE_OVER:         EQU 3           ; ゲーム状態：ゲームオーバー

; ■フォントパターンデータ
; &H0100〜
FONT_PTN_DATA:
    DB $00,$00,$00,$00,$00,$00,$00,$00
    DB $1C,$1C,$18,$18,$10,$00,$30,$30
    DB $36,$36,$12,$24,$00,$00,$00,$00
    DB $36,$36,$7F,$36,$7F,$36,$36,$00
    DB $08,$3E,$68,$3E,$0B,$3E,$08,$00
    DB $71,$52,$64,$08,$13,$25,$47,$00
    DB $30,$48,$58,$33,$6A,$44,$3B,$00
    DB $18,$18,$08,$10,$00,$00,$00,$00
    DB $0C,$18,$30,$30,$30,$18,$0C,$00
    DB $18,$0C,$06,$06,$06,$0C,$18,$00
    DB $18,$5A,$3C,$18,$3C,$5A,$18,$00
    DB $00,$18,$18,$7E,$18,$18,$00,$00
    DB $00,$00,$00,$00,$30,$10,$20,$00
    DB $00,$00,$00,$3E,$00,$00,$00,$00
    DB $00,$00,$00,$00,$00,$18,$18,$00
    DB $03,$07,$0E,$1C,$38,$70,$60,$00
    DB $1C,$26,$63,$63,$63,$32,$1C,$00
    DB $0C,$1C,$0C,$0C,$0C,$0C,$3F,$00
    DB $3E,$63,$07,$1E,$3C,$70,$7F,$00
    DB $3F,$06,$0C,$1E,$03,$63,$3E,$00
    DB $0E,$1E,$36,$66,$7F,$06,$06,$00
    DB $7E,$60,$7E,$03,$03,$63,$3E,$00
    DB $1E,$30,$60,$7E,$63,$63,$3E,$00
    DB $7F,$63,$06,$0C,$18,$18,$18,$00
    DB $3C,$62,$72,$3C,$4F,$43,$3E,$00
    DB $3E,$63,$63,$3F,$03,$06,$3C,$00
    DB $00,$18,$18,$00,$18,$18,$00,$00
    DB $00,$18,$18,$00,$18,$08,$10,$00
    DB $06,$0C,$18,$30,$18,$0C,$06,$00
    DB $00,$00,$7F,$00,$00,$7F,$00,$00
    DB $30,$18,$0C,$06,$0C,$18,$30,$00
    DB $3E,$63,$63,$06,$0C,$00,$0C,$0C
    DB $3E,$41,$5D,$55,$5F,$4C,$3E,$00
    DB $1C,$36,$63,$63,$7F,$63,$63,$00
    DB $7E,$63,$63,$7E,$63,$63,$7E,$00
    DB $1E,$33,$60,$60,$60,$33,$1E,$00
    DB $7C,$66,$63,$63,$63,$66,$7C,$00
    DB $3F,$30,$30,$3E,$30,$30,$3F,$00
    DB $7F,$60,$60,$7E,$60,$60,$60,$00
    DB $1F,$30,$60,$67,$63,$33,$1F,$00
    DB $63,$63,$63,$7F,$63,$63,$63,$00
    DB $3F,$0C,$0C,$0C,$0C,$0C,$3F,$00
    DB $03,$03,$03,$03,$03,$63,$3E,$00
    DB $63,$66,$6C,$78,$7C,$6E,$67,$00
    DB $30,$30,$30,$30,$30,$30,$3F,$00
    DB $63,$77,$7F,$7F,$6B,$63,$63,$00
    DB $63,$73,$7B,$7F,$6F,$67,$63,$00
    DB $3E,$63,$63,$63,$63,$63,$3E,$00
    DB $7E,$63,$63,$63,$7E,$60,$60,$00
    DB $3E,$63,$63,$63,$6F,$66,$3D,$00
    DB $7E,$63,$63,$67,$7C,$6E,$67,$00
    DB $3C,$66,$60,$3E,$03,$63,$3E,$00
    DB $3F,$0C,$0C,$0C,$0C,$0C,$0C,$00
    DB $63,$63,$63,$63,$63,$63,$3E,$00
    DB $63,$63,$63,$77,$3E,$1C,$08,$00
    DB $63,$63,$6B,$7F,$7F,$77,$63,$00
    DB $63,$77,$3E,$1C,$3E,$77,$63,$00
    DB $33,$33,$33,$1E,$0C,$0C,$0C,$00
    DB $7F,$07,$0E,$1C,$38,$70,$7F,$00
    DB $3C,$30,$30,$30,$30,$30,$3C,$00
    DB $66,$3C,$18,$7E,$18,$7E,$18,$00
    DB $3C,$0C,$0C,$0C,$0C,$0C,$3C,$00
    DB $1C,$36,$63,$00,$00,$00,$00,$00
    DB $00,$00,$00,$00,$00,$00,$7F,$00

; ■PCGパターンデータ
; &H0308〜
PCG_PTN_DATA:
    DB "a",$EF,$EF,$EF,$00,$FE,$FE,$FE,$00  ; a
    DB 0

; ■PCGカラーデータ
; &H2000〜、32byte
PCG_COLOR_DATA:
    DB $00,$00,$00,$00,$F1,$F1,$F1,$F1
    DB $F1,$F1,$F1,$F1,$81,$F1,$F1,$F1
    DB $F1,$F1,$F1,$F1,$F1,$F1,$F1,$F1
    DB $F1,$F1,$F1,$F1,$F1,$F1,$F1,$F1

; ■スプライトパターンデータ
SPR_PTN_DATA:
	; 00〜03：プレイヤーパターン1
	DB $0F,$1F,$1D,$1D,$1D,$FF,$E7,$E8
	DB $1F,$7F,$3F,$1F,$0F,$0F,$3E,$3E
	DB $F0,$F8,$B8,$B8,$B8,$F8,$E0,$10
	DB $F0,$FC,$FF,$C3,$B8,$B8,$38,$00
	; 04〜07：プレイヤーパターン2
	DB $0F,$1F,$1D,$1D,$1D,$1F,$07,$08
	DB $1F,$3F,$FF,$DF,$0F,$0F,$3E,$3E
	DB $F0,$F8,$B8,$B8,$B8,$F8,$E0,$10
	DB $F0,$FC,$FF,$FB,$F0,$F0,$7C,$7C
	; 08〜11：プレイヤーパターン3
	DB $0F,$1F,$1D,$1D,$1D,$1F,$07,$08
	DB $0F,$3F,$FF,$C3,$1D,$1D,$1C,$00
	DB $F0,$F8,$B8,$B8,$B8,$FF,$E7,$17
	DB $F8,$FE,$FC,$F8,$F0,$F0,$7C,$7C
	; 12〜15：ボール
    DB $07,$1F,$3F,$77,$6F,$FF,$DF,$FF
    DB $FF,$FF,$FF,$7F,$7F,$3F,$1F,$07
    DB $E0,$F8,$FC,$FE,$FE,$FF,$FF,$FF
    DB $FF,$FF,$FF,$FE,$FE,$FC,$F8,$E0

; ■面データ
; 1ブロック2z2キャラクターのため、1ライン2バイトx11行
ROUND_TBL:
    DW ROUND_1,00

ROUND_1:
    ; 32文字×22行
    ; VRAMの$4000〜に書き込む
;    DB "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
;    DB "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
;    DB "                                "
;    DB "                                "
;    DB "aaaaaa                    aaaaaa"
;    DB "aaaaaa                    aaaaaa"
;    DB "aaaaaaaaaa            aaaaaaaaaa"
;    DB "aaaaaaaaaa            aaaaaaaaaa"
;    DB "aaaaaaaaaaaa        aaaaaaaaaaaa"
;    DB "aaaaaaaaaaaa        aaaaaaaaaaaa"
;    DB "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
;    DB "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
;    DB "aaaaaaaaaaaa        aaaaaaaaaaaa"
;    DB "aaaaaaaaaaaa        aaaaaaaaaaaa"
;    DB "aaaaaaaaaa            aaaaaaaaaa"
;    DB "aaaaaaaaaa            aaaaaaaaaa"
;    DB "aaaaaa                    aaaaaa"
;    DB "aaaaaa                    aaaaaa"
;    DB "                                "
;    DB "                                "
;    DB "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
;    DB "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"

    ; 16byte x 11 = 176byte
    DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    DB 1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1
    DB 1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1
    DB 1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1
    DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    DB 1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1
    DB 1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1
    DB 1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1
    DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1

    ; 2byte x 11 = 22byte
;    DW $FFFF,$0000,$E007,$F81F,$FC3F
;    DW $FFFF,$FC3F,$F81F,$E007,$0000
;    DW $FFFF

; ■移動量データ
; Y座標、X座標の移動量をSTICKの値の順に定義
; 計算時の座標値は10倍とし、計算後の座標は1/10とする必要がある
MOVE_DATA:
    DW $0000,$0000                  ; STICK=0(未入力)
    DW $FF00,$0000                  ; STICK=1(上)
    DW $FF4F,$00B0                  ; STICK=2(右上)
    DW $0000,$0100                  ; STICK=3(右)
    DW $00B0,$00B0                  ; STICK=4(右下)
    DW $0100,$0000                  ; STICK=5(下)
    DW $00B0,$FF4F                  ; STICK=6(左下)
    DW $0000,$FF00                  ; STICK=7(左)
    DW $FF4F,$FF4F                  ; STICK=8(左上)

; ■アニメーションパターンテーブル
PTN_TBL:
	DB 1,1,1,2,2,2,3,3,3,2,2,2,0

; ■表示文字列データ
; dw : 表示先のVRAMアドレスのオフセット値(下位/上位)    
; db : 表示文字列、最後に0を設定すること
STRING1:
    DW $C400
	DB "aa HELLO MSX WORLD !! aa",0
STRING2:
    DW $8202
	DB "PROGRAMMED BY ABURI6800 2021",0
STRING3:
    DW $0D00
	DB "      ",0
STRING4:
    DW $0D00
	DB "HIT !!",0


; ====================================================================================================
; ワークエリア
; プログラム起動時にcrtでゼロでramに設定される 
; ====================================================================================================
SECTION bss_user

; ■入力バッファ(STICK)
; +0 : 現在の入力値
; +1 : 前回の入力値
INPUT_BUFF_STICK:
    DEFS 2

; ■入力バッファ(STRIG)
; +0 : 現在の入力値
; +1 : 前回の入力値
INPUT_BUFF_STRIG:
    DEFS 2

; ■VRAMアドレスワーク
VRAM_ADDR_WK:
    DEFS 2

; ■ゲーム状態
GAME_STATUS:
    DEFS 1

; ■ラウンド
ROUND:
    DEFS 1

; ■スコア
SCORE:
    DEFS 3

; ■タイム
TIME:
    DEFS 2

; ■残機
LEFT:
    DEFS 2

; ■プレイヤーミスカウント
PLAYER_MISS_CNT:
    DEFS 1

; ■乱数ワークエリア
RND_WK:
    DB 0

; ■アニメーションパターン参照アドレス
PTN_ADDR:
	DEFS 2

; ■スプライトキャラクターワークテーブル(10Byte)
; +0:Y座標(2byte)
; +2:X座標(2byte)
; +4:スプライトパターンNo
; +5:カラーコード(0=非表示)
; +6:属性テーブルNo
; +7:移動方向(STICKの値に対応)  
; +8:汎用
; +9:汎用
SPR_CHR_WK_TBL:
    DEFS 10*MAX_CHR_CNT

; ■スプライトアトリビュートワークテーブル(4byte*n)
; +0:スプライトアトリビュート1バイト目(Y座標)
; +1:スプライトアトリビュート2バイト目(X座標)
; +2:スプライトアトリビュート3バイト目(スプライトパターンNo)
; +3:スプライトアトリビュート4バイト目(カラーコード)
SPR_ATR_WK_TBL:
	DEFS 4*MAX_CHR_CNT


; ====================================================================================================
; ワークエリア
; プログラム起動時にcrtでramに値が設定される 
; ====================================================================================================
SECTION data_user

