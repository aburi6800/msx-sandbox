; ====================================================================================================
; asm06.asm
; ====================================================================================================
SECTION code_user
PUBLIC _main

_main:
; ====================================================================================================
; 初期処理
; ====================================================================================================
    CALL INIT                       ; 初期設定

    ; ■ゲーム状態をタイトル初期化に変更
    LD A,STATE_TITLE
    CALL CHANGE_STATE

    ; ■テスト：固定で表示
    LD HL,STRING_HEADER1
    CALL PRTSTR
    LD HL,STRING_HEADER2
    CALL PRTSTR


; ====================================================================================================
; メインループ
; ====================================================================================================
MAINLOOP:
    ; ■経過時間をカウントアップ
    CALL TICK_COUNT                 ; 初回はゼロフラグが立つ
    PUSH AF                         ; フラグを退避

    ; ■ゲーム状態の値からジャンプテーブルアドレスのオフセット値を求める
    LD A,(GAME_STATE)               ; A <- ゲーム状態
    LD C,A                          ; A=A*3
    ADD A,A
    ADD A,C

    LD B,0                          ; BC <- ジャンプテーブルのオフセット値
    LD C,A

    ; ■ジャンプテーブルの該当ステップにジャンプ
    POP AF                          ; フラグを復元
    LD HL,MAINLOOP_RET              ; 各ルーチンからのRET先のアドレスをスタックに積む
    PUSH HL
    LD HL,MAINLOOP_L1               ; HL <- ジャンプテーブルのアドレス
    ADD HL,BC                       ; HL=HL+BC（ゼロフラグは変化しない）
    JP (HL)

MAINLOOP_L1:
    JP TITLE                        ; ゲーム状態：タイトル
    JP GAME_INIT                    ; ゲーム状態：ゲーム初期化
    JP ROUND_START                  ; ゲーム状態：ラウンド開始
    JP GAME_MAIN                    ; ゲーム状態：ゲームメイン
    JP PLAYER_MISS                  ; ゲーム状態：プレイヤーミス
    JP OVER                         ; ゲーム状態：ゲームオーバー
    JP ROUND_CLEAR                  ; ゲーム状態：ラウンドクリアー

MAINLOOP_RET:
VSYNC:
	; ■垂直帰線待ち
	HALT

    ; ■キー入力値取得
    CALL GET_CONTROL

	JR MAINLOOP


; ====================================================================================================
; キー入力値取得サブルーチン
; @ToDo : 直前の入力値を退避するようにする（連射入力のため）
; ====================================================================================================
GET_CONTROL:
    CALL KILBUF                     ; BIOS キーバッファクリア
    OR A                            ; キャリーフラグクリア

    ; ■プレイヤー操作データ(STICK)を取得
    LD A,0                          ; A <- ジョイスティック番号=0(キーボード)
    CALL GTSTCK                     ; BIOS ジョイスティックの状態取得
                                    ; - Aレジスタに入力値が設定されている
    LD B,A                          ; B <- A

    PUSH BC                         ; BCレジスタを退避
    LD A,1                          ; A <- ジョイスティック番号=1(パッド1)
    CALL GTSTCK                     ; ジョイスティック入力取得
    POP BC                          ; BCレジスタを復帰
    OR B                            ; A=A OR B
                                    ; - キーボードとパッドの入力の OR を取る
                                    ;   最大で15となる

    LD (INPUT_BUFF_STICK), A        ; 現在の入力値を保存

    ; ■プレイヤー操作データ(STRIG)を取得
    LD D,0                          ; D <- 0
    LD A,0                          ; A <- ジョイスティック番号=0(キーボード)
    CALL GTTRIG                     ; BIOS トリガボタンの状態取得
                                    ; - $00 = 押されていない
                                    ; - $0FF = 押されている
    OR A
    JR Z,GET_CONTROL_L1
    LD D,1                          ; D <- 1

GET_CONTROL_L1:
    LD E,0                          ; E <- 0
    LD A,1                          ; A <- ジョイスティック番号=0(パッド1)
    CALL GTTRIG                     ; BIOS トリガボタンの状態取得
    OR A
    JR Z,GET_CONTROL_L2
    LD E,1                          ; E <- 1

GET_CONTROL_L2:
    LD A,D                          ; A=D OR E
    OR E                            

    LD (INPUT_BUFF_STRIG), A        ; 現在の入力値を保存

GET_CONTROL_EXIT:
    RET


; ====================================================================================================
; ゲーム状態変更
; IN A  : 変更するゲーム状態の値
; ====================================================================================================
CHANGE_STATE:
    LD (GAME_STATE),A
    CALL TICK_RESET

CHANGE_STATE_EXIT:
    RET


; ====================================================================================================
; 経過時間リセット
; ====================================================================================================
TICK_RESET:
    LD A,0                          ; A <- 0
    LD (TICK1+0),A
    LD (TICK1+1),A

TICK_RESET_EXIT:
    RET


; ====================================================================================================
; 経過時間カウント
; ====================================================================================================
TICK_COUNT:
    ; DEBUG
    LD HL,28
    LD A,(TICK1+1)
    CALL PRTHEX

    LD HL,30
    LD A,(TICK1)
    CALL PRTHEX
    ; DEBUGここまで

    LD HL,(TICK1)                    ; HL <- TICKの値

    LD A,H                          ; HL=0の場合、ゼロフラグが立つ
    OR L

    INC HL                          ; TICKをカウントアップ
    JR Z,TICK_COUNT_L1              ; ゼロフラグが立っていたら次の処理へ

    LD A,H                          ; ゼロでなければ次の処理へ
    OR L
    JR NZ,TICK_COUNT_L1

    LD L,1                          ; 1にリセット
    LD H,0

TICK_COUNT_L1:
    LD (TICK1),HL

TICK_COUNT_EXIT:
    RET


; ====================================================================================================
; タイトル
; ====================================================================================================
TITLE:
    ; ■初回のみ初期化を実行
    JR Z,TITLE_INIT

    ; ■スペースキーが押されたら状態変更
    LD A,(INPUT_BUFF_STRIG)     ; A <- トリガボタンの入力値

    OR A                        ; ゼロ(未入力)なら抜ける
    JR Z,TITLE_EXIT

    LD A,STATE_GAME_INIT        ; ゲーム状態 <- ゲーム開始
    CALL CHANGE_STATE

TITLE_EXIT:
    RET

TITLE_INIT:
    ; ■各変数初期化
    LD A,0
    LD (ROUND),A                    ; ラウンド数 <- 0

    ; ■タイトル画面作成
    CALL DRAW_MAP                   ; フィールド描画

    LD HL,TITLE1
    CALL PRTSTR
    LD HL,TITLE2
    CALL PRTSTR
    LD HL,TITLE3
    CALL PRTSTR
    LD HL,TITLE4
    CALL PRTSTR

TITLE_INIT_EXIT:
    RET


; ====================================================================================================
; ゲーム初期化
; ====================================================================================================
GAME_INIT:
    ; ■乱数初期化
    CALL INIT_RND

    ; ■各変数初期化
    LD A,1
    LD (ROUND),A                    ; ラウンド数 <- 1
    LD A,0
    LD (SCORE),A                    ; スコア <- 0
    LD A,3
    LD (LEFT),A                     ; 残機 <- 3

    ; ■ゲーム状態変更
    LD A,STATE_ROUND_START          ; ゲーム状態 <- ラウンド開始
    CALL CHANGE_STATE

GAME_INIT_EXIT:
    RET


; ====================================================================================================
; ラウンド開始
; ====================================================================================================
ROUND_START:
    ; ■初回のみの処理実行
    JR Z,ROUND_START_INIT

    ; ■TICKが180カウント(=3秒)経過してなければ抜ける
    LD BC,180
    LD HL,(TICK1)    
    SBC Hl,BC
    JR NZ,ROUND_START_EXIT

    ; ■マップ描画
    CALL DRAW_MAP

    ; ■キャラクター情報初期化
    LD HL,CHR_CNT
    LD (HL),0                       ; キャラクター出現数=0

    ; ■プレイヤー初期化
    ; @ToDo:マップデータの後に、プレイヤーの初期情報を置いて、そこから設定するようにしたい
    LD A,1
    CALL ADD_CHARACTER

    ; ■敵初期化
    ; @ToDo:マップデータの後に、敵の初期情報を置いて、そこから設定するようにしたい
    LD B,10
ROUND_START_L1:
    LD A,2
    CALL ADD_CHARACTER
    DJNZ ROUND_START_L1             ; 20回繰り返す

    ; ■ゲーム状態変更
    LD A,STATE_GAME_MAIN            ; ゲーム状態 <- ゲームメイン
    CALL CHANGE_STATE

ROUND_START_EXIT:
    RET

ROUND_START_INIT:
    LD HL,$1800+32*2                ; 書き込み開始アドレス
    LD BC,32*22                     ; 書き込みデータ長
    LD A,$20                        ; 書き込むデータ
    CALL FILVRM                     ; BIOS VRAM指定領域同一データ転送

    LD HL,STRING_ROUND_START
    CALL PRTSTR

    RET


; ====================================================================================================
; マップデータ描画サブルーチン
; 予め、メモリの(ROUND)にラウンド数を入れておくこと
; ====================================================================================================
DRAW_MAP:
    ; ■VRAMアドレスワーク設定
    LD H,$1A                        ; 書き込み開始VRAMアドレス = $1ADE
    LD L,$DE
    LD (VRAM_ADDR_WK),HL

    ; ■ラウンドテーブルのオフセット値算出
    LD A,(ROUND)                    ; A <- ラウンド数
    RLCA                            ; A=A*2
    LD B,0                          ; BC <- A
    LD C,A

    ; ■ラウンドデータの取得先アドレス算出
    ; - 遡って取得するので、末端のアドレスを算出する
    LD HL,ROUND_TBL                 ; HL <- ラウンドテーブルの取得先アドレス
    ADD HL,BC                       ; HL=HL+BC

    LD E,(HL)                       ; DE <- (HL) ラウンドデータの先頭アドレス
    INC HL
    LD D,(HL)
    LD BC,175                       ; BC <- ラウンドデータのbyte数
    PUSH DE
    POP HL
    ADD HL,BC                       ; HL=HL+BC

    ; ■フィールド描画ループ回数設定
    LD B,176                        ; フィールドデータカウント (176byte)
    
DRAW_MAP_L1:
    PUSH HL                         ; ラウンドデータの取得先アドレスをスタックに退避
    PUSH BC                         ; フィールドデータカウントをスタックに退避

    ; ■ラウンドデータからマップチップデータを取得
    LD A,(HL)                       ; A <- (HL)   

    ; ■取得した値からジャンプテーブルアドレスのオフセット値を求める
    LD C,A                          ; A=A*3
    ADD A,A
    ADD A,C

    LD B,0                          ; BC <- ジャンプテーブルのオフセット値
    LD C,A

    ; ■ジャンプテーブルの該当ステップにジャンプ
    LD HL,DRAW_MAP_L2               ; HL <- ジャンプテーブルのアドレス
    ADD HL,BC                       ; HL=HL+BC
    POP BC                          ; BC <- スタック(フィールドデータカウント)
    JP (HL)

DRAW_MAP_L2:
    JP DRAW_MAPCHIP_0               ; データ=0の描画
    JP DRAW_MAPCHIP_1               ; データ=1の描画

DRAW_MAP_L4:
    LD HL,(VRAM_ADDR_WK)            ; HL <- VRAMアドレスワーク
    DEC HL                          ; HL=HL-2
    DEC HL

    LD A,B                          ; Bレジスタを左に4ビットシフト
    DEC A
    SLA A
    SLA A
    SLA A
    SLA A
    JR NZ,DRAW_MAP_L5               ; ゼロではない(=16の倍数でない)場合はDRAW_MAP_L5へ

    OR A                            ; キャリーフラグをOFF
    LD DE,32                        ; HL=HL-32
    SBC HL,DE

DRAW_MAP_L5:
    LD (VRAM_ADDR_WK),HL            ; HL -> VRAMアドレスワーク

    POP HL                          ; HL <- スタック(ラウンドデータの取得先アドレス)
    DEC HL
    DJNZ DRAW_MAP_L1

DRAW_MAP_EXIT:
    RET

DRAW_MAPCHIP_0:
    ; 空白を描画(左上)
    LD HL,(VRAM_ADDR_WK)            ; HL <- VRAMアドレスワーク
    LD A,' '
    CALL WRTVRM

    ; 空白を描画(右上)
    INC HL                          ; HL=HL+1
    LD A,' '
    CALL WRTVRM

    ; 空白を描画(左下)
    LD DE,31                        ; HL=HL+31
    ADD HL,DE                   
    LD A,' '
    CALL WRTVRM

    ; 空白を描画(右下)
    INC HL                          ; HL=HL+1
    LD A,' '
    CALL WRTVRM

    JP DRAW_MAP_L4

DRAW_MAPCHIP_1:
    ; 床を描画(左上)
    LD HL,(VRAM_ADDR_WK)            ; HL <- VRAMアドレスワーク
    LD A,'a'
    CALL WRTVRM

    ; 床を描画(右上)
    INC HL                          ; HL=HL+1
    LD A,'a'
    CALL WRTVRM

    ; 床を描画(左下)
    LD DE,31                        ; HL=HL+31
    ADD HL,DE                   
    LD A,'a'
    CALL WRTVRM

    ; 床を描画(右下)
    INC HL                          ; HL=HL+1
    LD A,'a'
    CALL WRTVRM

    ; 画面最下段か
    LD A,B                          ; A <- B
    CP 160                          ; A > 160か
    JP NC,DRAW_MAP_L4               ; ゼロでなければ抜ける

    ; 更に左下の情報を取得
    LD DE,31
    ADD HL,DE
    CALL RDVRM                      ; BIOS RDVRM
    CP $20                          ; A > $20(空白)か
    JP NZ,DRAW_MAP_L4               ; ゼロでなければ抜ける

    ; 床のさらに下を描画
    LD A,'h'
    CALL WRTVRM
    INC HL
    LD A,'h'
    CALL WRTVRM

    JP DRAW_MAP_L4


; ====================================================================================================
; ゲームメイン
; ====================================================================================================
GAME_MAIN:
    ; ■スプライトキャラクターワークテーブルの全ての要素に対して繰り返し
    LD B,MAX_CHR_CNT

GAME_MAIN_L1:
    ; ■対象のキャラクター番号からスプライトキャラクターワークテーブルのアドレスを取得
    LD A,B
    SUB 1
    CALL GET_SPR_WK_ADDR            ; IX <- 対象のスプライトキャラクターワークテーブルのアドレス

    ; ■BCレジスタをスタックに退避
    PUSH BC

    ; ■対象のキャラクター番号からキャラクターロジックテーブルのアドレスを取得
    LD A,(IX)                       ; A <- キャラクター番号
    OR A
    JR Z,GAME_MAIN_L2               ; ゼロの場合はGAME_MAIN_L2へ
    LD HL,CHARACTER_UPDATE_TABLE    ; HL <- キャラクターロジックテーブルのアドレス
    CALL TBL_JP

GAME_MAIN_L2:
    ; ■BCレジスタをスタックから復元 
    POP BC

    DJNZ GAME_MAIN_L1

    ; ■画面更新
    CALL DRAW

GAME_MAIN_EXIT:
    RET


; ====================================================================================================
; ダミー処理サブルーチン
; ====================================================================================================
UPDATE_NONE:
    RET


; ====================================================================================================
; プレイヤー処理サブルーチン
; ====================================================================================================
UPDATE_PLAYER:
    ; ■プレイヤー操作不可カウント判定
    ; - プレイヤー操作不可カウント<>0の場合は、操作を受け付けずに終了する
    LD A,(PLAYER_MISS_CNT)          ; A <- プレイヤーミスカウント
    OR A
    JR Z,UPDATE_PLAYER_L1           ; ゼロの時だけプレイヤー操作処理へ

    ; ■プレイヤーを操作不可にする
    DEC A                           ; A=A-1
    LD (PLAYER_MISS_CNT),A          ; A -> プレイヤーミスカウント

    LD HL,STRING4                   ; 'OUT !!'表示
    CALL PRTSTR

    JR UPDATE_PLAYER_EXIT

UPDATE_PLAYER_L1:
    LD HL,STRING3
    CALL PRTSTR

    ; ■プレイヤー操作
    ; @ToDo:なぜか下方向だけ、一定量ごとに右に1ドット移動してしまう
    CALL PLAYER_CONTROL             ; プレイヤー操作処理
    CALL SPRITE_MOVE                ; スプライトキャラクター移動処理

    ; ■プレイヤーヒットチェック
    ; BGとの当たり判定を行う
    CALL PLAYER_HITCHECK

UPDATE_PLAYER_EXIT:
    RET

; ----------------------------------------------------------------------------------------------------
; プレイヤー操作サブルーチン
; ----------------------------------------------------------------------------------------------------
PLAYER_CONTROL:
    ; ■A <- 操作入力データ（方向）
    LD A,(INPUT_BUFF_STICK)

    ; DEBUG
    LD HL,30+32
    CALL PRTHEX
    ; DEBUGここまで

    ; ■入力データをスプライトキャラクターワークテーブルに保存
    LD (IX+7),A
    OR A
    RET Z

    ; ■スプライトパターン番号更新
    CALL PLAYER_ANIM

PLAYER_CTRL_EXIT:
    RET

; ----------------------------------------------------------------------------------------------------
; プレイヤーヒットチェックサブルーチン
; プレイヤーの座標からBGとの判定を行う
; ----------------------------------------------------------------------------------------------------
PLAYER_HITCHECK:
    ; ■プレイヤーキャラクターのY座標から、オフセットアドレスを求める
    LD A,(IX+2)                     ; A <- スプライトキャラクターワークテーブルのY座標(整数部)
    ADD A,12                        ; A=A+12
    SRL A                           ; A=A/8
    SRL A
    SRL A

    LD H,0                          ; HL <- A
    LD L,A

    ADD HL,HL                       ; HL=HL*32
    ADD HL,HL
    ADD HL,HL
    ADD HL,HL
    ADD HL,HL

    ; ■プレイヤーキャラクターのX座標から、オフセットアドレスを求める
    LD A,(IX+4)                     ; A <- スプライトキャラクターワークテーブルのX座標(整数部)
    ADD A,8                         ; A=A+8
    SRL A                           ; A=A/8
    SRL A
    SRL A

    ; ■Y座標で求めたオフセットアドレスに加算する
    LD D,0                          ; DE <- A
    LD E,A                          ;
    ADD HL,DE                       ; HL=HL+DE

    ; ■パターンネームアドレスの先頭アドレスを加算
    LD DE,PTN_NAME_ADDR             ; DE <- パターンネームアドレスの先頭アドレス
    ADD HL,DE                       ; HL=HL+DE

    ; ■VRAMの値を取得
    CALL RDVRM                      ; BIOS RDVRM
                                    ; A <- HLのVRAMアドレスから読み出した値
    ; ■読み出した値を判定
    SUB 32                          ; A=A-32
    JR NZ,PLAYER_HITCHECK_EXIT      ; ゼロでなければPLAYER_HITCHECK_EXITへ

PLAYER_HITCHECK_L1:
    LD HL,STRING5                   ; 'MISS !!'表示
    CALL PRTSTR

PLAYER_HITCHECK_EXIT:
    RET


; ----------------------------------------------------------------------------------------------------
; スプライトパターン番号更新サブルーチン
; IN  : B = スプライトキャラクター番号
; @ToDo:アニメーションパターンはスプライトキャラクターワークテーブルに持たせたい
;       - パターンテーブルNo(1byte)と現在のパターンカウント(1byte)をもたせる？
;       - するとスプライトキャラクターワークテーブルは10byteでは足りない、16byteにする？
;       - データ長は変更に対応できるように定数にしよう
;       - パターンテーブルNoとアドレスを対応させたテーブルを定義する必要あり
;       - ラベル名も直したい（PLAYERだけじゃないので）
; ----------------------------------------------------------------------------------------------------
PLAYER_ANIM:
    ; ここはキャラクターデータにパターンテーブルの番号を持たせて、
    ; パターンテーブルからアドレスを取得するようにしたい

    ; ■参照先のアニメーションパターンテーブルの次のアドレスを求める
    LD HL,(PTN_ADDR)			    ; HLレジスタにアニメーションパターンテーブルの参照アドレスの値をロード
                                    ; - 本来であれば、キャラクターごとにアニメーションパターンがちがうので、
                                    ;   スプライトキャラクターワークテーブルにこのアドレスを持っておきたい
    INC HL						    ; HL=HL+1(ひとつ次のデータのアドレスへ)

	; ■アニメーションパターンテーブルから値を取得する
	LD A,(HL)					    ; A <- (HL) (=アニメーションパターンテーブルの参照先アドレスの値)
    OR 0						    ; 0かどうか (0=アニメーションパターンテーブルの終端)
    JR NZ,PLAYER_ANIM_1             ; 0でなければPLAYER_ANIM_1にジャンプ

	; ■アニメーションパターンテーブルの参照先を先頭に戻す
    LD HL,PTN_TBL				    ; HLレジスタにアニメーションパターンテーブルの先頭アドレスを設定
	LD A,(HL)					    ; A <- (HL) (=アニメーションパターンテーブルの参照先アドレスの値)

PLAYER_ANIM_1:
	; ■アニメーションパターンテーブルからスプライトパターン番号を取得する
    LD (PTN_ADDR),HL			    ; アニメーションパターンテーブルの参照先アドレスを更新する

PLAYER_ANIM_2:
	SUB 1						    ; A=A-1（パターンテーブルの値はスプライトパターン番号+1が設定されているため）
	LD (IX+5),A		                ; A -> スプライトパターン番号

PLAYER_ANIM_EXIT:
    RET


; ====================================================================================================
; 敵１処理サブルーチン
; ====================================================================================================
UPDATE_ENEMY1:
    ; ■ボール移動
    CALL SPRITE_MOVE                ; スプライトキャラクター移動処理
    CALL ENEMY_BOUND                ; ボールバウンド処理

    ; ■ヒット判定
    LD A,(PLAYER_MISS_CNT)          ; プレイヤーミスカウント<>0なら衝突判定はしないで終了
    OR A
    JR NZ,UPDATE_ENEMY1_L1

    LD C,0                          ; C <- 衝突判定用の相手キャラクター番号
                                    ;      0 = プレイヤー
    CALL HIT_CHECK                  ; 衝突判定
    JR NC,UPDATE_ENEMY1_L1          ; ヒットしてなかったら終了
    LD A,20                         ; プレイヤーミスカウントを設定
    LD (PLAYER_MISS_CNT),A

UPDATE_ENEMY1_L1:
    RET 

; ----------------------------------------------------------------------------------------------------
; 敵バウンド処理
; ----------------------------------------------------------------------------------------------------
ENEMY_BOUND:
    ; ■移動方向のアドレスをHLレジスタに設定
    PUSH IX                         ; IX -> HL
    POP HL
    LD DE,7                         ; HL=HL+7
    ADD HL,DE                       ; HL=移動方向のアドレス

    ; ■Y座標をDレジスタに取得
    LD D,(IX+2)                     ; D <- Y座標(整数部)

ENEMY_BOUND_L1:
    ; ■Y座標が上端か調べる
    LD A,D
    CP 16
    JR NZ,ENEMY_BOUND_L2            ; 画面上端でなければ画面下端チェックへ

    ; ■Y座標が上端の場合の跳ね返りの方向決定
    ; - V=2の時：V=4
    ; - V=8の時：V=6
    LD A,(HL)                       ; A <- 今の移動方向
    LD (HL),4                       ; まずは次の移動方向を4とする
    CP 2
    JR Z,ENEMY_BOUND_L3             ; 移動方向=2の場合はこのままでいいので、画面左端チェックへ

    LD (HL),6                       ; V=8の時はここに来る、次の移動方向を6にする
    JR ENEMY_BOUND_L3               ; 画面上端の場合が画面下端チェックは不要、画面左端チェックへ

ENEMY_BOUND_L2:
    ; ■Y座標が画面下端か調べる
    LD A,D
    CP 191-16
    JR NZ,ENEMY_BOUND_L3            ; 画面下端でなければ画面左端チェックへ

    ; ■Y座標が下端の場合の跳ね返りの方向決定
    ; - V=4の時：V=2
    ; - V=6の時：V=8
    LD A,(HL)                       ; A <- 移動方向
    LD (HL),2                       ; まずは2とする
    CP 4

    JR Z,ENEMY_BOUND_L3
    LD (HL),8                       ; V=6の時はここに来る

ENEMY_BOUND_L3:
    ; ■X座標をDレジスタに取得
    LD D,(IX+4)                     ; D <- X座標(整数部)

    ; ■X座標が画面左端か調べる
    LD A,D
    CP 0
    JR NZ,ENEMY_BOUND_L4            ; 画面左端でなければ画面右端チェックへ

    ; ■跳ね返りの方向決定(X<0の時)
    ; - V=8の時：V=2
    ; - V=6の時：V=4
    LD A,(HL)                       ; A <- 移動方向
    LD (HL),2                       ; まずは2とする
    CP 8
    JR Z,ENEMY_BOUND_EXIT

    LD (HL),4                       ; V=6の時はここに来る
    JR ENEMY_BOUND_EXIT

ENEMY_BOUND_L4:
    ; ■X座標が右端か調べる
    LD A,D
    CP 255-16
    JR NZ,ENEMY_BOUND_EXIT          ; 画面右端でなければ終了

    ; ■跳ね返りの方向決定(X>239の時)
    ; - V=2の時：V=8
    ; - V=4の時：V=6
    LD A,(HL)                       ; A <- 移動方向
    LD (HL),8                       ; まずは2とする
    CP 2
    JR Z,ENEMY_BOUND_EXIT

    LD (HL),6                       ; V=6の時はここに来る

ENEMY_BOUND_EXIT:
    RET


; ====================================================================================================
; 敵２処理サブルーチン
; ====================================================================================================
UPDATE_ENEMY2:
    JP UPDATE_ENEMY1


; ====================================================================================================
; プレイヤーミス
; ====================================================================================================
PLAYER_MISS:


PLAYER_MISS_EXIT:
    RET


; ====================================================================================================
; ゲームオーバー
; ====================================================================================================
OVER:


OVER_EXIT:
    RET


; ====================================================================================================
; ラウンドクリアー
; ====================================================================================================
ROUND_CLEAR:


ROUND_CLEAR_EXIT:
    RET


; ====================================================================================================
; スプライトキャラクター移動処理
; 事前にIXにスプライトキャラクターワークテーブルの先頭アドレスを設定済であること
; @ToDo:IXレジスタの使用を最小限に抑えたい
; ====================================================================================================
SPRITE_MOVE:
    ; ■対象スプライトキャラクターの移動方向から移動量データのアドレス算出
    LD A,(IX+7)                     ; A=移動方向
    OR A                            ; 移動方向が0(=移動しない)場合は終了
    JR Z,SPRITE_MOVE_EXIT

    ; ■移動量データの取得
    RLCA                            ; A=A*2
    RLCA                            ; A=A*2、ここで移動量データのオフセットがAに設定される

    LD HL,MOVE_DATA                 ; HLレジスタに移動量データのアドレスを設定
    ADD HL,A

    PUSH HL                         ; HL -> IY
    POP IY

    ; ■Y座標計算
    LD B,(IY+1)                     ; BC <- 移動量データ(Y方向)
    LD C,(IY)
    LD H,(IX+2)                     ; HL <- Y座標
    LD L,(IX+1)
    ADC HL,BC                       ; HL=HL+BC

    ; ■Y座標チェック
    LD A,H                          ; 座標値チェック
    CP 191-16                       ; A=A-(191-16)
    JR C,SPRITE_MOVE_L1             ; キャリーフラグがONの場合は画面内なのでSPRITE_MOVE_L1へ

    LD H,0                          ; H=0
    CP 255-8                        ; 最大移動量を8と仮定した比較
    JR NC,SPRITE_MOVE_L1            ; キャリーフラグがOFF(=画面上部にはみ出てた場合)はHはそのままで良いのでSPRITE_MOVE_L1へ

    LD H,191-16                     ; H=(191-16)

SPRITE_MOVE_L1:
    ; ■Y座標を保存
    LD (IX+2),H                     ; H -> Y座標(整数部)
    LD (IX+1),L                     ; L -> Y座標(小数部)

    ; ■X座標計算
    LD B,(IY+3)                     ; BC <- 移動量データ(X方向)
    LD C,(IY+2)
    LD H,(IX+4)                     ; HL <- X座標
    LD L,(IX+3)
    ADC HL,BC                       ; HL=HL+BC

    ; ■X座標チェック
    LD A,H                          ; 座標値チェック
    CP 255-16                       ; A=A-(255-16)
    JR C,SPRITE_MOVE_L2             ; キャリーフラグがONの場合は画面内なのでSPRITE_MOVE_L2へ

    LD H,0                          ; H=0
    CP 255-8                        ; 最大移動量を8と仮定した比較
    JR NC,SPRITE_MOVE_L2            ; キャリーフラグがOFF(=画面左部にはみ出てた場合)はHはそのままで良いのでSPRITE_MOVE_L2へ

    LD H,255-16                     ; H=255-16

SPRITE_MOVE_L2:
    ; ■X座標を保存
    LD (IX+4),H
    LD (IX+3),L

SPRITE_MOVE_EXIT:
    RET


; ====================================================================================================
; キャラクター衝突判定処理
; 2つのキャラクターの座標を比較して、衝突していた場合はキャリーフラグを立てて戻る
; DE,HLレジスタの値を破壊します
; IN  : A = 比較元のスプライトキャラクターワークテーブルのインデックス
;       C = 比較先のスプライトキャラクターワークテーブルのインデックス
; OUT : キャリーフラグ(ON=衝突している、OFF=衝突していない)
; ====================================================================================================
HIT_CHECK:
    ; ■比較先のキャラクター番号からスプライトキャラクターワークテーブルのアドレスを求める
    ; - IXレジスタは比較元の情報として残しておきたいので、一度スタックに退避し、
    ;   ここで取得したアドレスはHLレジスタに入れておく
    PUSH IX

    LD A,C
    CALL GET_SPR_WK_ADDR
    PUSH IX                         ; IX -> HL
    POP HL

    POP IX

    ; ■Y座標の比較
    OR A                            ; キャリーフラグリセット
    LD A,(IX+2)                     ; A <- 比較元のY座標
    INC HL                          ; B <- 比較先のY座標
    INC HL
    LD B,(HL)                   
    CALL ABS_SUB                    ; 差分を絶対値で取得
    CP 10                           ; A < 10 の場合はキャリーフラグが立つ
    JR NC,HIT_CHECK_EXIT            ; キャリーフラグが立っていない場合は終了

    ; ■X座標の比較
    LD A,(IX+4)                     ; A <- 比較元のX座標
    INC HL                          ; B <- 比較先のX座標
    INC HL
    LD B,(HL)
    CALL ABS_SUB                    ; 差分を絶対値で取得
    CP 10                           ; A < 10 の場合はキャリーフラグが立つ

HIT_CHECK_EXIT:
    RET


; ====================================================================================================
; 画面更新
; ====================================================================================================
DRAW:
    DI

    ; ■スプライトキャラクターワークテーブルからスプライトアトリビュートワークテーブルを設定
    CALL SET_SPR_ATR_WK

    ; ■スプライトアトリビュートエリア設定
    CALL SET_SPR_ATTR_AREA

DRAW_EXIT:
    EI
    RET


; ====================================================================================================
; 初期設定
; ====================================================================================================
INIT:
    ; ■画面初期化
    CALL SCREEN_INIT

    ; ■フォントパターン定義
    CALL SET_FONT_PATTERN

    ; ■PCGパターン定義
    CALL SET_PCG_PATTERN

    ; ■カラーテーブル定義
    CALL SET_COLOR_TABLE

    ; ■スプライトパターン定義
    CALL SET_SPRITE_PATTERN

    ; ■スプライトキャラクターワークテーブル初期化
    CALL INIT_SPR_CHR_WK_TBL

    RET


; ====================================================================================================
; 画面初期化
; ====================================================================================================
SCREEN_INIT:
    ; ■COLOR 15,1,1
    LD A,15                         ; Aレジスタに文字色をロード 
    LD (FORCLR),A                   ; Aレジスタの値をワークエリアに格納
    LD A,1                          ; Aレジスタに全景色をロード
    LD (BAKCLR),A                   ; Aレジスタの値をワークエリアに格納
;    LD A,1                         ; Aレジスタに背景色をロード
    LD (BDRCLR),A                   ; Aレジスタの値をワークエリアに格納

    ; ■SCREEN 1,2,0
    LD A,(REG1SAV)                  ; AレジスタにVDPコントロールレジスタ1の値をロード
    OR 2                            ; ビット2を立てる(=スプライトモードを16x16に設定)
    LD (REG1SAV),A                  ; Aレジスタの値をVDPコントロールレジスタ1のワークエリアに格納
    LD A,1                          ; Aレジスタにスクリーンモードの値を設定
    CALL CHGMOD                     ; BIOS スクリーンモード変更
    LD A,0                          ; Aレジスタにキークリックスイッチの値(0=OFF)をロード
    LD (CLIKSW),A                   ; Aレジスタの値をワークエリアに格納

    ; ■WIDTH 32
    LD A,32                         ; AレジスタにWIDTHの値を設定
    LD (LINL32),A                   ; Aレジスタの値をワークエリアに格納

    ; ■KEY OFF
    CALL ERAFNC                     ; BIOS ファンクションキー非表示

    RET


; ====================================================================================================
; フォントパターン定義
; ====================================================================================================
SET_FONT_PATTERN:
	LD HL,FONT_PTN_DATA			    ; HLレジスタに転送元データの先頭アドレスを設定
    LD DE,PTN_GEN_ADDR+32*8         ; DEレジスタに転送先アドレスを設定
	LD BC,8*64					    ; BCレジスタにデータサイズを指定
    CALL LDIRVM					    ; BIOS VRAMブロック転送

    RET


; ====================================================================================================
; PCGパターン定義
; ====================================================================================================
SET_PCG_PATTERN:
    LD HL,PCG_PTN_DATA              ; HL <- PCGデータの先頭アドレス

SET_PCG_PATTERN_L1:
    LD A,(HL)                       ; A <- PCGデータのキャラクターコード
    OR A                            ; A=ゼロなら抜ける
    JR Z,SET_PCG_PATTERN_EXIT

    ; DEレジスタにコピー先のアドレスを設定
    ; $0000+キャラクターコード*8
    PUSH HL                         ; HLを退避
    LD H,0                          ; HL <- A
    LD L,A
    ADD HL,HL                       ; HL=HL*8
    ADD HL,HL
    ADD HL,HL
    LD D,H                          ; DE <- HL
    LD E,L    
    POP HL

    ; HLレジスタにコピー元のアドレスを設定
    INC HL                          ; HL=HL+1
    
    ; BCレジスタに転送バイト数を設定
    LD BC,8                         ; 8バイトを転送
    PUSH BC
    PUSH HL
    CALL LDIRVM                     ; BIOS VRAMブロック転送
    POP HL
    POP BC
    
    ADD HL,BC                       ; HL <- 次のPCGデータのアドレス(+8)
    JR SET_PCG_PATTERN_L1

SET_PCG_PATTERN_EXIT:
    RET


; ====================================================================================================
; カラーテーブル定義
; ====================================================================================================
SET_COLOR_TABLE:
    LD HL,PCG_COLOR_DATA            ; HL <- PCGカラーデータの先頭アドレス
    LD DE,COLOR_TABLE_ADDR          ; DE <- カラーテーブルの先頭アドレス
    LD BC,32                        ; BC <- 転送バイト数
    CALL LDIRVM                     ; BIOS VRAMブロック転送

SET_COLOR_TABLE_EXIT:
    RET


; ====================================================================================================
; スプライトパターン定義
; ====================================================================================================
SET_SPRITE_PATTERN:
	LD HL,SPR_PTN_DATA			    ; HLレジスタにスプライトデータの先頭アドレスを設定
    LD DE,SPR_PTN_ADDR			    ; DEレジスタにスプライトパターンジェネレータの先頭アドレスを設定
	LD BC,8*7*4					    ; BCレジスタにスプライトデータのサイズを指定
    CALL LDIRVM				 	    ; BIOS VRAMブロック転送

SET_SPRITE_PATTERN_EXIT:
    RET


; ====================================================================================================
; スプライトキャラクターワークテーブル初期化
; ====================================================================================================
INIT_SPR_CHR_WK_TBL:
    LD B,MAX_CHR_CNT                ; 最大キャラクター数

INIT_SPR_CHR_WK_TBL_L1:
    CALL GET_SPR_WK_ADDR            ; スプライトキャラクターワークテーブルのアドレスを取得

    LD (IX),0                       ; Y座標
    LD (IX+1),0                     ; Y座標(小数)
    LD (IX+2),-16                   ; Y座標(整数)
    LD (IX+3),0                     ; X座標(小数)
    LD (IX+4),-16                   ; X座標(整数)
    LD (IX+5),0                     ; スプライトパターンNo
    LD (IX+6),0                     ; カラーコード
    LD (IX+7),0                     ; 属性テーブルNo(0=なし)
    LD (IX+8),0                     ; 移動方向

    DJNZ INIT_SPR_CHR_WK_TBL_L1

INIT_SPR_CHR_WK_TBL_EXIT:
    RET 


; ====================================================================================================
; キャラクター出現サブルーチン
; 最大キャラクター出現数に達している場合は何もせずに終了する
; キャラクター出現可能な場合は、キャラクター出現数を増加させて対象キャラクター番号の
; データをスプライトキャラクターワークテーブルに登録する
; IN  : A = 対象のキャラクター番号
; ====================================================================================================
ADD_CHARACTER:
    PUSH AF                         ; AFレジスタをスタックに退避

    ; ■キャラクター出現数チェック
    LD A,(CHR_CNT)                  ; A <- 現在のキャラクター出現数
    CP MAX_CHR_CNT                  ; Aと最大キャラクター出現数を比較
    RET Z                           ; ゼロ(出現キャラクター数が最大)ならリターン

    ; ■キャラクター出現数からスプライトキャラクターワークテーブルのアドレスを取得
    CALL GET_SPR_WK_ADDR

    ; ■キャラクター出現数加算
    INC A
    LD (CHR_CNT),A                  ; 現在のキャラクター出現数をワークに格納

    ; ■対象のキャラクター番号からキャラクター初期化テーブルのアドレスを取得
    POP AF                          ; AFをスタックから復元
    LD HL,CHARACTER_INIT_TABLE      ; HL <- キャラクター初期化テーブルのアドレス
    CALL TBL_JP

    ; ■初期化処理呼び出し
;    JP (HL)                         ; 初期化処理へジャンプ

ADD_CHARACTER_EXIT:
    RET


; ====================================================================================================
; 初期化ダミー
; ====================================================================================================
INIT_NONE:
    RET


; ====================================================================================================
; プレイヤー初期化
; ====================================================================================================
INIT_PLAYER:
    LD (IX),1                       ; キャラクター番号=プレイヤー

    LD (IX+1),0                     ; Y座標(小数部)
    LD (IX+2),88                    ; Y座標(整数部)

    LD (IX+3),0                     ; X座標(小数部)
    LD (IX+4),120                   ; X座標(整数部)

    LD (IX+5),0                     ; スプライトパターンNo
    LD (IX+6),15                    ; カラーコード
    LD (IX+7),0                     ; 移動方向

    LD (IX+8),0                     ; アニメーションテーブル番号
    LD (IX+9),0                     ; アニメーションカウンタ

	LD HL,PTN_TBL				    ; アニメーションパターンテーブル参照先アドレス初期化
    LD (PTN_ADDR),HL

INIT_PLAYER_EXIT:
    RET


; ====================================================================================================
; 敵１初期化
; ====================================================================================================
INIT_ENEMY1:
    LD (IX),2                       ; キャラクター番号=敵１

INIT_ENEMY1_L2:
    ; ■Y座標設定
    CALL GET_RND                    ; 乱数取得(0〜255)
    ADD A,16                        ; 最低でもYは16以上とする
    CP 176                          ; A=A-176
    JR NC,INIT_ENEMY1_L2            ; Aが176を超えていたら再度乱数取得
    LD H,A
    LD L,0
    LD (IX+1),L                     ; Y座標(下位)
    LD (IX+2),H                     ; Y座標(上位)

INIT_ENEMY1_L3:
    ; ■X座標設定
    CALL GET_RND                    ; 乱数取得(0〜255)
    CP 248                          ; A=A-248
    JR NC,INIT_ENEMY1_L3            ; Aが248を超えていたら再度乱数取得
    LD H,A
    LD L,0
    LD (IX+3),L                     ; X座標(下位)
    LD (IX+4),H                     ; X座標(上位)

    ; ■パターンNo設定
    LD (IX+5),3                     ; パターンNo=3(ボール)
    
INIT_ENEMY1_L4:
    ; ■カラーコード設定
    CALL GET_RND                    ; 乱数取得(0〜255)
    AND 15                          ; 取得した乱数から0〜15の値を取得する
    ADD A,1                         ; A=A+1
    ADD A,1                         ; A=A+1
    CP 15                           ; Aが15を超えていたら再度乱数取得
    JR NC,INIT_ENEMY1_L4 
    LD (IX+6),A                     ; カラーコード

    ; ■方向設定
    CALL GET_RND                    ; 乱数取得(0〜255)
    AND @00000111                   ; 取得した乱数から0〜7の値を取得する
    ADD A,2                         ; A=A+2(カラーコード=1は除外するため)
    AND @00001110                   ; 下位1ビットを0にする()=2,4,6,8の値にする)
    LD (IX+7),A                     ; 方向

    LD (IX+8),1                     ; アニメーションテーブル番号
    LD (IX+9),0                     ; アニメーションカウンタ

INIT_ENEMY1_EXIT:
	RET


; ====================================================================================================
; 敵２初期化
; ====================================================================================================
INIT_ENEMY2:
    JP INIT_ENEMY1


; ====================================================================================================
; キャラクター削除サブルーチン
; IN  : A = 対象のスプライトキャラクターワークテーブルのインデックス
; ====================================================================================================
DEL_CHARACTER:
    ; ■対象のキャラクター番号からスプライトキャラクターワークテーブルのアドレスを取得
    CALL GET_SPR_WK_ADDR

    ; ■スプライトキャラクターワークテーブルの属性をゼロにする
    LD (IX),0                       

DEL_CHARACTER_EXIT:
    RET


; ====================================================================================================
; スプライトキャラクターワークテーブルからスプライトアトリビュートワークテーブルを設定する
; ====================================================================================================
SET_SPR_ATR_WK:
    LD B,MAX_CHR_CNT                ; スプライトキャラクター分繰り返し
    LD HL,SPR_CHR_WK_TBL            ; スプライトキャラクターワークテーブルの先頭アドレス
    LD DE,SPR_ATR_WK_TBL            ; スプライトアトリビュートワークテーブルの先頭アドレス

SET_SPR_ATR_WK_L1:
    ; ■Y座標
    INC HL                          ; HL=HL+2 (Y座標の上位1バイトのアドレス)
    INC HL
    LD A,(HL)                       ; (HL)→A
    LD (DE),A                       ; A→(DE)

    ; ■X座標
    INC HL                          ; HL=HL+2 (X座標の上位1バイトのアドレス)
    INC HL
    LD A,(HL)                       ; (HL)→A
    INC DE                          ; DE=DE+1
    LD (DE),A                       ; A→(DE)

    ; ■スプライトパターンNo
    INC HL                          ; HL=HL+1
    LD A,(HL)                       ; (HL)→A
    ADD A,A                         ; A=A*4 (スプライトが16x16なので、パターンNoを4倍する)
    ADD A,A
    INC DE                          ; DE=DE+1
    LD (DE),A                       ; A→(DE)

    ; ■カラーコード
    INC HL                          ; HL=HL+1
    LD A,(HL)                       ; (HL)→A
    INC DE                          ; DE=DE+1
    LD (DE),A                       ; A→(DE)

    ; ■設定元のスプライトキャラクターワークテーブルのアドレスを次の先頭アドレスへ
    PUSH BC                         ; 3
    LD BC,10                        ; 3 HL=HL+10
    ADD HL,BC                       ; 3
    POP BC                          ; 3
    
    ; ■設定先のスプライトアトリビュートワークテーブルのアドレスを次の先頭アドレスへ
    INC DE                          ; DE=DE+1

    DJNZ SET_SPR_ATR_WK_L1

SET_SPR_ATR_WK_EXIT:
    RET


; ====================================================================================================
; スプライトアトリビュートエリア設定
; ====================================================================================================
SET_SPR_ATTR_AREA:
    LD HL,SPR_ATR_WK_TBL            ; スプライトアトリビュートワークテーブル
    LD DE,SPR_ATR_ADDR              ; スプライトアトリビュートエリア
    LD BC,4*MAX_CHR_CNT             ; 転送バイト数(4byte*キャラクター数)
    CALL LDIRVM                     ; BIOS VRAMブロック転送

SET_SPR_ATTR_AREA_EXIT:
    RET 


; ====================================================================================================
; 文字列表示サブルーチン
; IN  : HL = 表示文字データの開始アドレス
; ====================================================================================================
PRTSTR:
    LD B,(HL)                       ; BC <- HLアドレスの示すオフセット値データ
    INC HL
    LD C,(HL)

    INC HL                          ; HL <- 文字列データの先頭アドレス
    PUSH HL                         ; HL -> DE
    POP DE

    LD HL,PTN_NAME_ADDR             ; HL <- パターンネームテーブルの先頭アドレス
    ADD HL,BC                       ; HL=HL+BC

PRTSTR_L1:
	LD A,(DE)				        ; AレジスタにDEレジスタの示すアドレスのデータを取得
	OR 0					        ; 0かどうか
    JR Z,PRTSTR_END			        ; 0の場合はPRTENDへ

	CALL WRTVRM				        ; BIOS WRTVRM呼び出し
	    					        ; - HL : 書き込み先のVRAMアドレス
    	                            ; - A  : 書き込むデータ

	INC HL					        ; HL=HL+1
    INC DE					        ; DE=DE+1
    JR PRTSTR_L1

PRTSTR_END:
	RET


; ====================================================================================================
; 16進数表示サブルーチン
; IN  : A = 表示対象データ
;       HL = 表示位置のVRAMアドレスオフセット値
; ====================================================================================================
PRTHEX:
    PUSH AF
    ; ■VRAMアドレス算出
    LD DE,HL                        ; DE <- HL
    LD HL,PTN_NAME_ADDR             ; HL <- パターンネームテーブルの先頭アドレス
    ADD HL,DE                       ; HL=HL+DE

    ; ■表示対象データの上位4ビットに対する表示文字コード算出
    PUSH AF                         ; AFレジスタを一旦スタックに退避
    SRL A                           ; 右シフトx4
    SRL A
    SRL A
    SRL A
    CALL PRTHEX_GETCHR              ; Aレジスタの値からキャラクタコードを求める

    ; ■VRAM書き込み
    CALL WRTVRM

    ; ■VRAMアドレスをインクリメント
    INC HL

    ; ■表示対象データの下位4ビットに対する表示文字コード算出
    POP AF                          ; AFレジスタをスタックから復帰
    AND @00001111                   ; 下位4ビットを取り出し
    CALL PRTHEX_GETCHR              ; Aレジスタの値からキャラクタコードを求める

    ; ■VRAM書き込み
    CALL WRTVRM

PRTHEX_EXIT:
    POP AF
    RET

PRTHEX_GETCHR:
    OR A                            ; キャリーフラグリセット
    CP 10                           ; A < 10の場合はキャリーフラグが立つ
    JR C,PRTHEX_GETCHR_L1
    ADD A,$37                       ; A〜F
    RET

PRTHEX_GETCHR_L1:
    ADD A,$30                       ; 0〜9
    RET


; ====================================================================================================
; 絶対値減算サブルーチン
; IN  : A = 値１
;       B = 値２
; OUT : A = A-Bの絶対値
; ====================================================================================================
ABS_SUB:
    OR A
    SUB B                           ; A=A-B
    JP M,ABS_SUB_L1                 ; マイナスだったらABS_SUB_L1へ
    RET

ABS_SUB_L1:
    NEG                             ; 上記の結果を正負反転
	ADD A,$FF                       ; A=A+$FF
    ADD A,1                         ; さらに1加算して一巡させる
    RET


; ====================================================================================================
; アドレステーブルによるジャンプ処理
; IN  : HL = 対象テーブルの先頭アドレス
;       A = インデックスNo(0～)
; OUT : HL = 指定したインデックスに登録されているアドレス
; @ToDo : 戻り先のアドレスをスタックに積むのはここに入れて、JPさせるのもここでやる
; ====================================================================================================
TBL_JP:
    RLCA                            ; A=A*2
    LD D,0                          ; DE <- アドレスのオフセットと値
    LD E,A
    ADD HL,DE

    LD E,(HL)                       ; DE <- キャラクター初期化テーブルの値
    INC HL
    LD D,(HL)

    LD HL,TBL_JP_EXIT               ; 戻り先のアドレスをスタックに設定
    PUSH HL

    EX DE,HL                        ; HL <- DE

    JP (HL)

TBL_JP_EXIT:
    RET


; ====================================================================================================
; 乱数初期化サブルーチン
; ====================================================================================================
INIT_RND:
    LD A,(INTCNT)
    LD (RND_WK),A                   ; 乱数のシード値を設定

INIT_RND_EXIT:
    RET


; ====================================================================================================
; 乱数取得サブルーチン
; 事前にINIT_RNDを実行しておくこと
; OUT : A = 0〜255の範囲の乱数
; ====================================================================================================
GET_RND:
    PUSH BC
    
    LD A,(RND_WK)                   ; 乱数のシード値を乱数ワークエリアから取得
    LD B,A
    LD A,B

    ADD A,A                         ; A=A*5
    ADD A,A                         ;
    ADD A,B                         ;

    ADD A,123                       ; 123を加える
    LD (RND_WK),A                   ; 乱数ワークエリアに保存

GET_RND_EXIT:
    POP BC
    RET


; ====================================================================================================
; スプライトキャラクターワークテーブルのアドレス値を求める
; SPR_CHR_WK_TBL+(キャラクターNo*16)のアドレスを求めてIXレジスタに設定します。
; DE,HLレジスタの値を破壊します。
; IN  : A = キャラクターNo
; OUT : IX = 求めたスプライトキャラクターワークテーブルのアドレス
; ====================================================================================================
GET_SPR_WK_ADDR:
    ; ■スプライトキャラクターワークテーブルの先頭アドレス
    LD IX,SPR_CHR_WK_TBL            ; IXに設定

    ; ■算出対象かチェック
    OR A
    JR Z,GET_SPR_WK_ADDR_EXIT       ; A=0ならそのまま終了する

    ; ■オフセット値算出
    ; DEレジスタにA*16を求める
    LD H,0                          ; HL=A
    LD L,A

    ADD HL,HL                       ; HL=HL*16
    ADD HL,HL
    ADD HL,HL
    ADD HL,HL

    LD D,H                          ; HL -> DE
    LD E,L

    ; ■スプライトキャラクターワークテーブルのアドレス算出
    LD HL,SPR_CHR_WK_TBL            ; HL=スプライトキャラクターワークテーブルの先頭アドレス
    ADD HL,DE                       ; HL=HL+DE

    PUSH HL                         ; HL -> IX
    POP IX

GET_SPR_WK_ADDR_EXIT:
    RET 


; ====================================================================================================
; 定数エリア
; romに格納される
; ====================================================================================================
SECTION rodata_user

; ■BIOSアドレス定義
RDVRM:		            EQU $004A	; BIOS RDVRM
WRTVRM:		            EQU $004D	; BIOS WRTVRM
FILVRM:			        EQU	$0056	; BIOS VRAM指定領域同一データ転送
LDIRVM:			        EQU	$005C	; BIOS VRAMブロック転送
CHGMOD:                 EQU $005F   ; BIOS スクリーンモード変更
ERAFNC:                 EQU $00CC   ; BIOS ファンクションキー非表示
KILBUF:                 EQU $0156   ; BIOS キーバッファクリア
GTSTCK:                 EQU $00D5   ; BIOS ジョイスティックの状態取得
GTTRIG:                 EQU $00D8   ; BIOS トリガボタンの状態取得

; ■システムワークエリアアドレス定義
REG0SAV:                EQU $F3DF   ; VDPコントロールレジスタ0
REG1SAV:                EQU $F3E0   ; VDPコントロールレジスタ1
FORCLR:                 EQU $F3E9   ; 前景色
BAKCLR:                 EQU $F3EA   ; 背景色
BDRCLR:                 EQU $F3EB   ; 周辺色
LINL32:                 EQU $F3AF   ; WIDTH値
CLIKSW:                 EQU $F3DB   ; キークリックスイッチ(0:OFF,0以外:ON)
INTCNT:                 EQU $FCA2   ; システムで1/60秒でインクリメントするワークエリア

; ■VRAMワークエリアアドレス定義
PTN_GEN_ADDR:           EQU $0000   ; VRAM パターンジェネレータテーブルの先頭アドレス
PTN_NAME_ADDR:          EQU $1800   ; VRAM パターンネームテーブルの先頭アドレス
COLOR_TABLE_ADDR:       EQU $2000   ; VRAM カラーテーブルの先頭アドレス
SPR_PTN_ADDR:	        EQU $3800	; VRAM スプライトパターンジェネレータの先頭アドレス
SPR_ATR_ADDR:	        EQU	$1B00	; VRAM スプライトアトリビュートエリアの先頭アドレス

; ■定数定義
MAX_CHR_CNT:            EQU 32      ; 最大キャラクター数
MAX_BALL_CNT:           EQU 5       ; 最大ボール数

STATE_TITLE:            EQU 0       ; ゲーム状態：タイトル
STATE_GAME_INIT:        EQU 1       ; ゲーム状態：ゲーム初期化
STATE_ROUND_START:      EQU 2       ; ゲーム状態：ラウンド開始
STATE_GAME_MAIN:        EQU 3       ; ゲーム状態：ゲームメイン
STATE_PLAYER_MISS:      EQU 4       ; ゲーム状態：プレイヤーミス
STATE_OVER:             EQU 5       ; ゲーム状態：ゲームオーバー
STATE_ROUND_CLEAR:      EQU 6       ; ゲーム状態：ラウンドクリアー

SPR_CHR_WK_SIZE:        EQU 16      ; スプライトキャラクターワークエリアのサイズ

; ■フォントパターンデータ
; &H0100〜
FONT_PTN_DATA:
    DB $00,$00,$00,$00,$00,$00,$00,$00
    DB $1C,$1C,$18,$18,$10,$00,$30,$30
    DB $36,$36,$12,$24,$00,$00,$00,$00
    DB $36,$36,$7F,$36,$7F,$36,$36,$00
    DB $08,$3E,$68,$3E,$0B,$3E,$08,$00
    DB $71,$52,$64,$08,$13,$25,$47,$00
    DB $30,$48,$58,$33,$6A,$44,$3B,$00
    DB $18,$18,$08,$10,$00,$00,$00,$00
    DB $0C,$18,$30,$30,$30,$18,$0C,$00
    DB $18,$0C,$06,$06,$06,$0C,$18,$00
    DB $18,$5A,$3C,$18,$3C,$5A,$18,$00
    DB $00,$18,$18,$7E,$18,$18,$00,$00
    DB $00,$00,$00,$00,$30,$10,$20,$00
    DB $00,$00,$00,$3E,$00,$00,$00,$00
    DB $00,$00,$00,$00,$00,$18,$18,$00
    DB $03,$07,$0E,$1C,$38,$70,$60,$00
    DB $1C,$26,$63,$63,$63,$32,$1C,$00
    DB $0C,$1C,$0C,$0C,$0C,$0C,$3F,$00
    DB $3E,$63,$07,$1E,$3C,$70,$7F,$00
    DB $3F,$06,$0C,$1E,$03,$63,$3E,$00
    DB $0E,$1E,$36,$66,$7F,$06,$06,$00
    DB $7E,$60,$7E,$03,$03,$63,$3E,$00
    DB $1E,$30,$60,$7E,$63,$63,$3E,$00
    DB $7F,$63,$06,$0C,$18,$18,$18,$00
    DB $3C,$62,$72,$3C,$4F,$43,$3E,$00
    DB $3E,$63,$63,$3F,$03,$06,$3C,$00
    DB $00,$18,$18,$00,$18,$18,$00,$00
    DB $00,$18,$18,$00,$18,$08,$10,$00
    DB $06,$0C,$18,$30,$18,$0C,$06,$00
    DB $00,$00,$7F,$00,$00,$7F,$00,$00
    DB $30,$18,$0C,$06,$0C,$18,$30,$00
    DB $3E,$63,$63,$06,$0C,$00,$0C,$0C
    DB $3E,$41,$5D,$55,$5F,$4C,$3E,$00
    DB $1C,$36,$63,$63,$7F,$63,$63,$00
    DB $7E,$63,$63,$7E,$63,$63,$7E,$00
    DB $1E,$33,$60,$60,$60,$33,$1E,$00
    DB $7C,$66,$63,$63,$63,$66,$7C,$00
    DB $3F,$30,$30,$3E,$30,$30,$3F,$00
    DB $7F,$60,$60,$7E,$60,$60,$60,$00
    DB $1F,$30,$60,$67,$63,$33,$1F,$00
    DB $63,$63,$63,$7F,$63,$63,$63,$00
    DB $3F,$0C,$0C,$0C,$0C,$0C,$3F,$00
    DB $03,$03,$03,$03,$03,$63,$3E,$00
    DB $63,$66,$6C,$78,$7C,$6E,$67,$00
    DB $30,$30,$30,$30,$30,$30,$3F,$00
    DB $63,$77,$7F,$7F,$6B,$63,$63,$00
    DB $63,$73,$7B,$7F,$6F,$67,$63,$00
    DB $3E,$63,$63,$63,$63,$63,$3E,$00
    DB $7E,$63,$63,$63,$7E,$60,$60,$00
    DB $3E,$63,$63,$63,$6F,$66,$3D,$00
    DB $7E,$63,$63,$67,$7C,$6E,$67,$00
    DB $3C,$66,$60,$3E,$03,$63,$3E,$00
    DB $3F,$0C,$0C,$0C,$0C,$0C,$0C,$00
    DB $63,$63,$63,$63,$63,$63,$3E,$00
    DB $63,$63,$63,$77,$3E,$1C,$08,$00
    DB $63,$63,$6B,$7F,$7F,$77,$63,$00
    DB $63,$77,$3E,$1C,$3E,$77,$63,$00
    DB $33,$33,$33,$1E,$0C,$0C,$0C,$00
    DB $7F,$07,$0E,$1C,$38,$70,$7F,$00
    DB $3C,$30,$30,$30,$30,$30,$3C,$00
    DB $66,$3C,$18,$7E,$18,$7E,$18,$00
    DB $3C,$0C,$0C,$0C,$0C,$0C,$3C,$00
    DB $1C,$36,$63,$00,$00,$00,$00,$00
    DB $00,$00,$00,$00,$00,$00,$7F,$00

; ■PCGパターンデータ
; &H0308〜
PCG_PTN_DATA:
;    DB "a",$EF,$EF,$EF,$00,$FE,$FE,$FE,$00  ; a
    DB "a",$FE,$FF,$FF,$BF,$FF,$FF,$EF,$FF  ; a
    DB "h",$FF,$EE,$2A,$A8,$02,$20,$00,$00  ; h
    DB 0

; ■PCGカラーデータ
; &H2000〜、32byte
PCG_COLOR_DATA:
    DB $00,$00,$00,$00,$F1,$F1,$F1,$F1
    DB $F1,$F1,$F1,$F1,$81,$41,$F1,$F1
    DB $F1,$F1,$F1,$F1,$F1,$F1,$F1,$F1
    DB $F1,$F1,$F1,$F1,$F1,$F1,$F1,$F1

; ■スプライトパターンデータ
SPR_PTN_DATA:
	; 00〜03：プレイヤーパターン1
	DB $0F,$1F,$1D,$1D,$1D,$FF,$E7,$E8
	DB $1F,$7F,$3F,$1F,$0F,$0F,$3E,$3E
	DB $F0,$F8,$B8,$B8,$B8,$F8,$E0,$10
	DB $F0,$FC,$FF,$C3,$B8,$B8,$38,$00
	; 04〜07：プレイヤーパターン2
	DB $0F,$1F,$1D,$1D,$1D,$1F,$07,$08
	DB $1F,$3F,$FF,$DF,$0F,$0F,$3E,$3E
	DB $F0,$F8,$B8,$B8,$B8,$F8,$E0,$10
	DB $F0,$FC,$FF,$FB,$F0,$F0,$7C,$7C
	; 08〜11：プレイヤーパターン3
	DB $0F,$1F,$1D,$1D,$1D,$1F,$07,$08
	DB $0F,$3F,$FF,$C3,$1D,$1D,$1C,$00
	DB $F0,$F8,$B8,$B8,$B8,$FF,$E7,$17
	DB $F8,$FE,$FC,$F8,$F0,$F0,$7C,$7C
	; 12〜15：モンスターA(右１)
    DB $01,$07,$0E,$0D,$0D,$1E,$1F,$1F
    DB $3D,$BE,$FE,$7F,$3F,$0F,$01,$00
    DB $F0,$3C,$DE,$EE,$AF,$DF,$3F,$FF
    DB $FF,$FF,$2B,$01,$A8,$FE,$FC,$00
    ; 16～20：モンスターA(右2)
    DB $00,$01,$07,$0E,$0D,$0D,$1E,$1F
    DB $1F,$BF,$FF,$FE,$7F,$3F,$0F,$01
    DB $00,$F0,$3C,$DE,$AE,$EF,$DF,$3F
    DB $FF,$FF,$FF,$AA,$55,$FF,$FE,$FC
    ; 21～24：モンスターA(左1)
    DB $0F,$3C,$7B,$77,$F5,$FB,$FC,$FF
    DB $FF,$FF,$D4,$80,$15,$7F,$3F,$00
    DB $80,$E0,$70,$B0,$B0,$78,$F8,$F8
    DB $BC,$7D,$7F,$FE,$FC,$F0,$80,$00
    ; 25～28：モンスターA(左2)
    DB $00,$0F,$3C,$7B,$75,$F7,$FB,$FC
    DB $FF,$FF,$FF,$55,$AA,$FF,$7F,$3F
    DB $00,$80,$E0,$70,$B0,$B0,$78,$F8
    DB $F8,$FD,$FF,$7F,$FE,$FC,$F0,$80

; ■移動量データ
; Y座標、X座標の移動量をSTICKの値の順に定義
; 計算時の座標値は10倍とし、計算後の座標は1/10とする必要がある
; STICKの値は、キーボードとパッドの入力の OR を取る
; 9以降は両方同時に入力された時のためのダミーデータ(最大15となる)
MOVE_DATA:
    DW $0000,$0000                  ; STICK=0(未入力)
    DW $FF00,$0000                  ; STICK=1(上)
    DW $FF4F,$00B0                  ; STICK=2(右上)
    DW $0000,$0100                  ; STICK=3(右)
    DW $00B0,$00B0                  ; STICK=4(右下)
    DW $0100,$0000                  ; STICK=5(下)
    DW $00B0,$FF4F                  ; STICK=6(左下)
    DW $0000,$FF00                  ; STICK=7(左)
    DW $FF4F,$FF4F                  ; STICK=8(左上)
    DW $0000,$0000                  ; STICK=9
    DW $0000,$0000                  ; STICK=10
    DW $0000,$0000                  ; STICK=11
    DW $0000,$0000                  ; STICK=12
    DW $0000,$0000                  ; STICK=13
    DW $0000,$0000                  ; STICK=14
    DW $0000,$0000                  ; STICK=15

; ■キャラクター初期化テーブル
; 1 : プレイヤー
; 2 : 敵１
; 3 : 敵２
CHARACTER_INIT_TABLE:
    DW INIT_NONE
    DW INIT_PLAYER
    DW INIT_ENEMY1
    DW INIT_ENEMY2

; ■キャラクターロジックテーブル
; 1 : プレイヤー
; 2 : 敵１
; 3 : 敵２
CHARACTER_UPDATE_TABLE:
    DW UPDATE_NONE
    DW UPDATE_PLAYER
    DW UPDATE_ENEMY1
    DW UPDATE_ENEMY2

; ■アニメーションパターンテーブル
ANIM_PTN_TBL:
    DW ANIM_PTN_PLAYER
    DW ANIM_PTN_ENEMY1
    DW ANIM_PTN_ENEMY2

PTN_TBL:
	DB 1,1,1,2,2,2,3,3,3,2,2,2,0
ANIM_PTN_PLAYER:
	DB 1,1,1,2,2,2,3,3,3,2,2,2,0
ANIM_PTN_ENEMY1:
	DB 3,0
ANIM_PTN_ENEMY2:
	DB 3,0

; ■ラウンドデータテーブル
ROUND_TBL:
    DW MAP_TITLE,MAP_ROUND1,00

MAP_TITLE:
    ; 16byte x 11 = 176byte
    DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    DB 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
    DB 1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1
    DB 1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1
    DB 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
    DB 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
    DB 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
    DB 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
    DB 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
    DB 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
    DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1

MAP_ROUND1:
    ; 32文字×22行=704byte
    ; VRAMの$4000〜に書き込む
;    DB "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
;    DB "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
;    DB "                                "
;    DB "                                "
;    DB "aaaaaa                    aaaaaa"
;    DB "aaaaaa                    aaaaaa"
;    DB "aaaaaaaaaa            aaaaaaaaaa"
;    DB "aaaaaaaaaa            aaaaaaaaaa"
;    DB "aaaaaaaaaaaa        aaaaaaaaaaaa"
;    DB "aaaaaaaaaaaa        aaaaaaaaaaaa"
;    DB "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
;    DB "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
;    DB "aaaaaaaaaaaa        aaaaaaaaaaaa"
;    DB "aaaaaaaaaaaa        aaaaaaaaaaaa"
;    DB "aaaaaaaaaa            aaaaaaaaaa"
;    DB "aaaaaaaaaa            aaaaaaaaaa"
;    DB "aaaaaa                    aaaaaa"
;    DB "aaaaaa                    aaaaaa"
;    DB "                                "
;    DB "                                "
;    DB "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
;    DB "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"

    ; 16byte x 11 = 176byte
    DB 0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0
    DB 0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0
    DB 1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1
    DB 1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1
    DB 1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1
    DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    DB 1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1
    DB 1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1
    DB 1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1
    DB 0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0
    DB 0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0

    ; 2byte x 11 = 22byte
;    DW $FFFF,$0000,$E007,$F81F,$FC3F
;    DW $FFFF,$FC3F,$F81F,$E007,$0000
;    DW $FFFF

; ■表示文字列データ
; dw : 表示先のVRAMアドレスのオフセット値(下位/上位)    
; db : 表示文字列、最後に0を設定すること
TITLE1:
    DW $E800
	DB " HELLO          ",0
TITLE2:
    DW $0801
	DB "    MSX WORLD ! ",0
TITLE3:
    DW $0502
	DB "PUSH SPACE OR TRIGGER.",0
TITLE4:
    DW $8202
	DB "PROGRAMMED BY ABURI6800 2021",0
STRING_ROUND_START:
    DW $0901
	DB "READY ROUND 1",0
STRING_HEADER1:
    DW $0000
    DB "SCORE       HI-SCORE    RD  LEFT"
STRING_HEADER2:
    DW $2000
    DB "       0       76500     0     0"
STRING3:
    DW $0D00
	DB "      ",0
STRING4:
    DW $0D00
	DB "HIT !!",0
STRING5:
    DW $0D00
	DB "OUT !!",0


; ====================================================================================================
; ワークエリア
; プログラム起動時にcrtでゼロでramに設定される 
; ====================================================================================================
SECTION bss_user
; ■経過時間カウンタ
TICK1:
    DEFS 2                      ; 1/60のタイマー
TICK2:
    DEFS 2                      ; 1/10のタイマー、TICK=6ごとにインクリメント
TICK3:
    DEFS 2                      ; 1秒のタイマー、TICK1=60ごとにインクリメント

; ■入力バッファ(STICK)
; +0 : 現在の入力値
; +1 : 前回の入力値
INPUT_BUFF_STICK:
    DEFS 2

; ■入力バッファ(STRIG)
; +0 : 現在の入力値
; +1 : 前回の入力値
INPUT_BUFF_STRIG:
    DEFS 2

; ■VRAMアドレスワーク
VRAM_ADDR_WK:
    DEFS 2

; ■キャラクター出現数
CHR_CNT:
    DEFS 1

; ■ゲーム状態
GAME_STATE:
    DEFS 1

; ■ラウンド
ROUND:
    DEFS 1

; ■スコア
SCORE:
    DEFS 3

; ■タイム
TIME:
    DEFS 2

; ■残機
LEFT:
    DEFS 2

; ■プレイヤーミスカウント
PLAYER_MISS_CNT:
    DEFS 1

; ■乱数ワークエリア
RND_WK:
    DB 0

; ■アニメーションパターン参照アドレス
; @ToDo:スプライトキャラクターワークエリアにこのアドレス or パターンテーブル番号を持たせたい
PTN_ADDR:
	DEFS 2

; ■スプライトキャラクターワークテーブル(16Byte)
; +0:キャラクター番号
; +1:Y座標(小数部)
; +2:Y座標(整数部)
; +3:X座標(小数部)
; +4:X座標(整数部)
; +5:スプライトパターンNo
; +6:カラーコード(0=非表示)
; +7:移動方向(STICKの値に対応)  
; +8:アニメーションテーブル番号
; +9:アニメーションカウンタ
; +10:汎用
; +11:汎用
; +12:汎用
; +13:汎用
; +14:汎用
; +15:汎用
SPR_CHR_WK_TBL:
    DEFS SPR_CHR_WK_SIZE*MAX_CHR_CNT

; ■スプライトアトリビュートワークテーブル(4byte*n)
; +0:スプライトアトリビュート1バイト目(Y座標)
; +1:スプライトアトリビュート2バイト目(X座標)
; +2:スプライトアトリビュート3バイト目(スプライトパターンNo)
; +3:スプライトアトリビュート4バイト目(カラーコード)
SPR_ATR_WK_TBL:
	DEFS 4*MAX_CHR_CNT


; ====================================================================================================
; ワークエリア
; プログラム起動時にcrtでramに値が設定される 
; ====================================================================================================
SECTION data_user

